<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
<title>Quantum PL & Verification Bibliography</title>
<link rel=stylesheet type="text/css" href="https://latex.now.sh/style.css">
</head>

<body>
<h1>bbt.bib</h1><a name="Abramsky2004"></a><pre>
@inproceedings{<a href="bbt.html#Abramsky2004">Abramsky2004</a>,
  title = {A Categorical Semantics of Quantum Protocols},
  author = {Abramsky, Samson and Coecke, Bob},
  year = {2004},
  month = jul,
  booktitle = {Proceedings of the 19th Annual IEEE Symposium on Logic in Computer Science},
  publisher = {{IEEE Computer Society}},
  address = {Los Alamitos, CA, USA},
  series = {{{LICS}} '04},
  pages = {415--425},
  doi = {10.1109/LICS.2004.1319636},
  archiveprefix = {arXiv},
  eprint = {quant-ph/0402130},
  abstract = {We study quantum information and computation from a novel point of view. Our approach is based on recasting the standard axiomatic presentation of quantum mechanics, due to von Neumann, at a more abstract level, of compact closed categories with biproducts. We show how the essential structures found in key quantum information protocols such as teleportation, logic-gate teleportation, and entanglement-swapping can be captured at this abstract level. Moreover, from the combination of the -- apparently purely qualitative -- structures of compact closure and biproducts there emerge 'scalars' and a 'Born rule'. This abstract and structural point of view opens up new possibilities for describing and reasoning about quantum systems. It also shows the degrees of axiomatic freedom: we can show what requirements are placed on the (semi)ring of scalars C(I,I), where C is the category and I is the tensor unit, in order to perform various protocols such as teleportation. Our formalism captures both the information-flow aspect of the protocols (see quant-ph/0402014), and the branching due to quantum indeterminism. This contrasts with the standard accounts, in which the classical information flows are 'outside' the usual quantum-mechanical formalism.},
  keywords = {protocols, teleportation, performance evaluation, quantum computing, quantum entanglement, quantum mechanics, laboratories, communication channels, force measurement, measurement standards},
  webnote = {Also see updated version: \cite{Abramsky2008}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Abramsky2008"></a><pre>
@incollection{<a href="bbt.html#Abramsky2008">Abramsky2008</a>,
  title = {Categorical Quantum Mechanics},
  author = {Abramsky, Samson and Coecke, Bob},
  year = {2008},
  month = nov,
  booktitle = {Handbook of Quantum Logic and Quantum Structures},
  editor = {Engesser, Kurt and Gabbay, Dov M. and Lehmann, Daniel},
  publisher = {Elsevier},
  address = {Amsterdam},
  pages = {261--323},
  doi = {10.1016/B978-0-444-52869-8.50010-4},
  archiveprefix = {arXiv},
  eprint = {0808.1023},
  abstract = {This invited chapter in the Handbook of Quantum Logic and Quantum Structures consists of two parts: 1. A substantially updated version of quant-ph/0402130 by the same authors, which initiated the area of categorical quantum mechanics, but had not yet been published in full length; 2. An overview of the progress which has been made since then in this area.},
  keywords = {protocols, teleportation, performance evaluation, quantum computing, quantum entanglement, quantum mechanics, laboratories, communication channels, force measurement, measurement standards},
  webnote = {Substantially updated version of \cite{Abramsky2004} by the same authors.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Altenkirch2005"></a><pre>
@inproceedings{<a href="bbt.html#Altenkirch2005">Altenkirch2005</a>,
  title = {A Functional Quantum Programming Language},
  author = {Altenkirch, Thorsten and Grattage, Jonathan},
  year = {2005},
  month = jun,
  booktitle = {Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science},
  publisher = {{IEEE Computer Society}},
  address = {Los Alamitos, CA, USA},
  series = {{{LICS}} '05},
  pages = {249--258},
  doi = {10.1109/LICS.2005.1},
  archiveprefix = {arXiv},
  eprint = {quant-ph/0409065},
  abstract = {We introduce the language QML, a functional language for quantum computations on finite types. Its design is guided by its categorical semantics: QML programs are interpreted by morphisms in the category FQC of finite quantum computations, which provides a constructive semantics of irreversible quantum computations realisable as quantum gates. QML integrates reversible and irreversible quantum computations in one language, using first order strict linear logic to make weakenings explicit. Strict programs are free from decoherence and hence preserve superpositions and entanglement - which is essential for quantum parallelism.},
  keywords = {quantum computing, quantum entanglement, functional programming, quantum gates, formal logic, quantum entanglement, functional languages},
  webnote = {Introduces QML, see also \cite{Grattage2011}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Altenkirch2009"></a><pre>
@incollection{<a href="bbt.html#Altenkirch2009">Altenkirch2009</a>,
  title = {The {{Quantum IO Monad}}},
  author = {Altenkirch, Thorsten and Green, Alexander S.},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  pages = {173--205},
  crossref = {<a href="#Gay2009">Gay2009</a>},
  doi = {10.1017/CBO9781139193313.006},
  url = {<a href="https://www.cs.nott.ac.uk/~psztxa/g5xnsc/chapter.pdf">https://www.cs.nott.ac.uk/~psztxa/g5xnsc/chapter.pdf</a>},
  abstract = {The quantum IO monad is a purely functional interface to quantum programming implemented as a Haskell library. At the same time it provides a constructive semantics of quantum programming. The QIO monad separates reversible (i.e., unitary) and irreversible (i.e., probabilistic) computations and provides a reversible let operation (ulet), allowing us to use ancillas (auxiliary qubits) in a modular fashion. QIO programs can be simulated either by calculating a probability distribution or by embedding it into the IO monad using the random number generator. As an example we present a complete implementation of Shor's algorithm.},
  webnote = {Also see \cite{Green2010} for a reimplementation in Agda.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Amy2019"></a><pre>
@inproceedings{<a href="bbt.html#Amy2019">Amy2019</a>,
  title = {Towards Large-Scale Functional Verification of Universal Quantum Circuits},
  author = {Amy, Matthew},
  year = {2019},
  month = jan,
  booktitle = {Proceedings of the 15th International Conference on Quantum Physics and Logic (QPL), Halifax, Canada, June 3--7, 2018},
  editor = {Selinger, Peter and Chiribella, Giulio},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {287},
  pages = {1--21},
  doi = {10.4204/EPTCS.287.1},
  abstract = {We introduce a framework for the formal specification and verification of quantum circuits based on the Feynman path integral. Our formalism, built around exponential sums of polynomial functions, provides a structured and natural way of specifying quantum operations, particularly for quantum implementations of classical functions. Verification of circuits over all levels of the Clifford hierarchy with respect to either a specification or reference circuit is enabled by a novel rewrite system for exponential sums with free variables. Our algorithm is further shown to give a polynomial-time decision procedure for checking the equivalence of Clifford group circuits. We evaluate our methods by performing automated verification of optimized Clifford+T circuits with up to 100 qubits and thousands of T gates, as well as the functional verification of quantum algorithms using hundreds of qubits. Our experiments culminate in the automated verification of the Hidden Shift algorithm for a class of Boolean functions in a fraction of the time it has taken recent algorithms to simulate.},
  keywords = {sum-over-paths},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Amy2019a"></a><pre>
@phdthesis{<a href="bbt.html#Amy2019a">Amy2019a</a>,
  title = {Formal Methods in Quantum Circuit Design},
  author = {Amy, Matthew},
  year = {2019},
  month = feb,
  school = {University of Waterloo},
  address = {Waterloo, Ontario, Canada},
  url = {<a href="http://hdl.handle.net/10012/14480">http://hdl.handle.net/10012/14480</a>},
  abstract = {The design and compilation of correct, efficient quantum circuits is integral to the future operation of quantum computers. This thesis makes contributions to the problems of optimizing and verifying quantum circuits, with an emphasis on the development of formal models for such purposes. We also present software implementations of these methods, which together form a full stack of tools for the design of optimized, formally verified quantum oracles. On the optimization side, we study methods for the optimization of Rz and CNOT gates in Clifford+Rz circuits. We develop a general, efficient optimization algorithm called phase folding, which reduces the number of Rz gates without increasing any metrics by computing its phase polynomial. This algorithm can further be combined with synthesis techniques for CNOT-dihedral operators to optimize circuits with respect to particular costs. We then study the optimal synthesis problem for CNOT-dihedral operators from the perspectives of Rz and CNOT gate optimization. In the case of Rz gate optimization, we show that the optimal synthesis problem is polynomial-time equivalent to minimum-distance decoding in certain Reed-Muller codes. For the CNOT optimization problem, we show that the optimal synthesis problem is at least as hard as a combinatorial problem related to Gray codes. In both cases, we develop heuristics for the optimal synthesis problem, which together with phase folding reduces T counts by 42\% and CNOT counts by 22\% across a suite of real-world benchmarks. From the perspective of formal verification, we make two contributions. The first is the development of a formal model of quantum circuits with ancillary bits based on the Feynman path integral, along with a concrete verification algorithm. The path integral model, with some syntactic sugar, further doubles as a natural specification language for quantum computations. Our experiments show some practical circuits with up to hundreds of qubits can be efficiently verified. Our second contribution is a formally verified, optimizing compiler for reversible circuits. The compiler compiles a classical, irreversible language to reversible circuits, with a formal, machine-checked proof of correctness written in the proof assistant F*. The compiler is structured as a partial evaluator, allowing verification to be carried out significantly faster than previous results.},
  keywords = {quantum computing, quantum circuits, compiler optimization, formal verification, sum-over-paths},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Amy2019b"></a><pre>
@inproceedings{<a href="bbt.html#Amy2019b">Amy2019b</a>,
  title = {Sized {{Types}} for {{Low}}-{{Level Quantum Metaprogramming}}},
  author = {Amy, Matthew},
  year = {2019},
  month = may,
  booktitle = {Reversible Computation (RC '19)},
  editor = {Thomsen, Michael Kirkedal and Soeken, Mathias},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {11497},
  pages = {87--107},
  doi = {10.1007/978-3-030-21500-2_6},
  archiveprefix = {arXiv},
  eprint = {1908.02644},
  abstract = {One of the most fundamental aspects of quantum circuit design is the concept of families of circuits parametrized by an instance size. As in classical programming, metaprogramming allows the programmer to write entire families of circuits simultaneously, an ability which is of particular importance in the context of quantum computing as algorithms frequently use arithmetic over non-standard word lengths. In this work, we introduce metaQASM, a typed extension of the openQASM language supporting the metaprogramming of circuit families. Our language and type system, built around a lightweight implementation of sized types, supports subtyping over register sizes and is moreover type-safe. In particular, we prove that our system is strongly normalizing, and as such any well-typed metaQASM program can be statically unrolled into a finite circuit.},
  keywords = {quantum programming, circuit description languages, metaprogramming, openqasm, qasm},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Amy2020"></a><pre>
@article{<a href="bbt.html#Amy2020">Amy2020</a>,
  title = {staq -- A full-stack quantum processing toolkit},
  author = {Amy, Matthew and Gheorghiu, Vlad},
  year = {2020},
  month = jun,
  journal = {Quantum Science and Technology},
  publisher = {{IOP Publishing}},
  volume = {5},
  number = {3},
  eid = {034016},
  pages = {034016},
  numpages = {21},
  doi = {10.1088/2058-9565/ab9359},
  archiveprefix = {arXiv},
  eprint = {1912.06070},
  url = {<a href="https://github.com/softwareQinc/staq">https://github.com/softwareQinc/staq</a>},
  abstract = {We describe staq, a full-stack quantum processing toolkit written in standard C++. staq is a quantum compiler toolkit, comprising of tools that range from quantum optimizers and translators to physical mappers for quantum devices with restricted connectives. The design of staq is inspired from the UNIX philosophy of `less is more', i.e. staq achieves complex functionality via combining (piping) small tools, each of which performs a single task using the most advanced current state-of-the-art methods. We also provide a set of illustrative benchmarks.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="ArdeshirLarijani2018"></a><pre>
@article{<a href="bbt.html#ArdeshirLarijani2018">ArdeshirLarijani2018</a>,
  title = {Automated Equivalence Checking of Concurrent Quantum Systems},
  author = {{Ardeshir-Larijani}, Ebrahim and Gay, Simon J. and Nagarajan, Rajagopal},
  year = {2018},
  month = nov,
  journal = {ACM Transactions on Computational Logic},
  publisher = {{Association for Computing Machinery}},
  volume = {19},
  number = {4},
  eid = {28},
  pages = {28},
  numpages = {32},
  doi = {10.1145/3231597},
  url = {<a href="http://eprints.gla.ac.uk/166295/">http://eprints.gla.ac.uk/166295/</a>},
  abstract = {The novel field of quantum computation and quantum information has gathered significant momentum in the last few years. It has the potential to radically impact the future of information technology and influence the development of modern society. The construction of practical, general purpose quantum computers has been challenging, but quantum cryptographic and communication devices have been available in the commercial marketplace for several years. Quantum networks have been built in various cities around the world and a dedicated satellite has been launched by China to provide secure quantum communication. Such new technologies demand rigorous analysis and verification before they can be trusted in safety- and security-critical applications. Experience with classical hardware and software systems has shown the difficulty of achieving robust and reliable implementations.We present CCSq, a concurrent language for describing quantum systems, and develop verification techniques for checking equivalence between CCSq processes. CCSq has well-defined operational and superoperator semantics for protocols that are functional, in the sense of computing a deterministic input-output relation for all interleavings arising from concurrency in the system. We have implemented QEC (Quantum Equivalence Checker), a tool that takes the specification and implementation of quantum protocols, described in CCSq, and automatically checks their equivalence. QEC is the first fully automatic equivalence checking tool for concurrent quantum systems. For efficiency purposes, we restrict ourselves to Clifford operators in the stabilizer formalism, but we are able to verify protocols over all input states. We have specified and verified a collection of interesting and practical quantum protocols, ranging from quantum communication and quantum cryptography to quantum error correction.},
  keywords = {concurrency, process calculi, equivalence checking, quantum information processing, programming language semantics},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Backens2014"></a><pre>
@article{<a href="bbt.html#Backens2014">Backens2014</a>,
  title = {The {ZX}-calculus is complete for stabilizer quantum mechanics},
  author = {Backens, Miriam},
  year = {2014},
  month = sep,
  journal = {New Journal of Physics},
  publisher = {{IOP Publishing}},
  volume = {16},
  number = {9},
  eid = {093021},
  pages = {093021},
  doi = {10.1088/1367-2630/16/9/093021},
  abstract = {The ZX-calculus is a graphical calculus for reasoning about quantum systems and processes. It is known to be universal for pure state qubit quantum mechanics (QM), meaning any pure state, unitary operation and post-selected pure projective measurement can be expressed in the ZX-calculus. The calculus is also sound, i.e. any equality that can be derived graphically can also be derived using matrix mechanics. Here, we show that the ZX-calculus is complete for pure qubit stabilizer QM, meaning any equality that can be derived using matrices can also be derived pictorially. The proof relies on bringing diagrams into a normal form based on graph states and local Clifford operations.},
  keywords = {zx-calculus},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Badescu2015"></a><pre>
@inproceedings{<a href="bbt.html#Badescu2015">Badescu2015</a>,
  title = {Quantum Alternation: {{Prospects}} and Problems},
  author = {B{\u a}descu, Costin and Panangaden, Prakash},
  year = {2015},
  month = nov,
  booktitle = {Proceedings of the 12th International Workshop on Quantum Physics and Logic (QPL), Oxford, U.K., July 15--17, 2015},
  editor = {Heunen, Chris and Selinger, Peter and Vicary, Jamie},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {195},
  pages = {33--42},
  doi = {10.4204/EPTCS.195.3},
  abstract = {We propose a notion of quantum control in a quantum programming language which permits the superposition of finitely many quantum operations without performing a measurement. This notion takes the form of a conditional construct similar to the IF statement in classical programming languages. We show that adding such a quantum IF statement to the QPL programming language simplifies the presentation of several quantum algorithms. This motivates the possibility of extending the denotational semantics of QPL to include this form of quantum alternation. We give a denotational semantics for this extension of QPL based on Kraus decompositions rather than on superoperators. Finally, we clarify the relation between quantum alternation and recursion, and discuss the possibility of lifting the semantics defined by Kraus operators to the superoperator semantics defined by Selinger.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Baez2010"></a><pre>
@incollection{<a href="bbt.html#Baez2010">Baez2010</a>,
  title = {Physics, Topology, Logic and Computation: {{A}} Rosetta Stone},
  author = {Baez, John C. and Stay, Mike},
  year = {2010},
  month = jul,
  booktitle = {New Structures for Physics},
  editor = {Coecke, Bob},
  publisher = {Springer},
  address = {{Berlin, Heidelberg}},
  pages = {95--172},
  doi = {10.1007/978-3-642-12821-9_2},
  archiveprefix = {arXiv},
  eprint = {0903.0340},
  abstract = {In physics, Feynman diagrams are used to reason about quantum processes. In the 1980s, it became clear that underlying these diagrams is a powerful analogy between quantum physics and topology. Namely, a linear operator behaves very much like a ``cobordism'': a manifold representing spacetime, going between two manifolds representing space. This led to a burst of work on topological quantum field theory and ``quantum topology''. But this was just the beginning: similar diagrams can be used to reason about logic, where they represent proofs, and computation, where they represent programs. With the rise of interest in quantum cryptography and quantum computation, it became clear that there is extensive network of analogies between physics, topology, logic and computation. In this expository paper, we make some of these analogies precise using the concept of ``closed symmetric monoidal category''. We assume no prior knowledge of category theory, proof theory or computer science.},
  keywords = {monoidal category, intuitionistic logic, lambda calculus},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Bettelli2003"></a><pre>
@article{<a href="bbt.html#Bettelli2003">Bettelli2003</a>,
  title = {Toward an Architecture for Quantum Programming},
  author = {Bettelli, Stefano and Calarco, Tommaso and Serafini, Luciano},
  year = {2003},
  month = aug,
  journal = {European Physical Journal D: Atomic, Molecular, Optical and Plasma Physics},
  volume = {25},
  number = {2},
  pages = {181--200},
  doi = {10.1140/epjd/e2003-00242-2},
  archiveprefix = {arXiv},
  eprint = {cs/0103009},
  abstract = {It is becoming increasingly clear that, if a useful device for quantum computation will ever be built, it will be embodied by a classical computing machine with control over a truly quantum subsystem, this apparatus performing a mixture of classical and quantum computation. This paper investigates a possible approach to the problem of programming such machines: a template high level quantum language is presented which complements a generic general purpose classical language with a set of quantum primitives. The underlying scheme involves a run-time environment which calculates the byte-code for the quantum operations and pipes it to a quantum device controller or to a simulator. This language can compactly express existing quantum algorithms and reduce them to sequences of elementary operations; it also easily lends itself to automatic, hardware independent, circuit simplification. A publicly available preliminary implementation of the proposed ideas has been realised using the language.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Bichsel2020"></a><pre>
@inproceedings{<a href="bbt.html#Bichsel2020">Bichsel2020</a>,
  title = {Silq: A High-Level Quantum Language with Safe Uncomputation and Intuitive Semantics},
  shorttitle = {Silq},
  author = {Bichsel, Benjamin and Baader, Maximilian and Gehr, Timon and Vechev, Martin},
  year = {2020},
  month = jun,
  booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{PLDI}} '20},
  pages = {286--300},
  doi = {10.1145/3385412.3386007},
  url = {<a href="https://files.sri.inf.ethz.ch/website/papers/pldi20-silq.pdf">https://files.sri.inf.ethz.ch/website/papers/pldi20-silq.pdf</a>},
  abstract = {Existing quantum languages force the programmer to work at a low level of abstraction leading to unintuitive and cluttered code. A fundamental reason is that dropping temporary values from the program state requires explicitly applying quantum operations that safely uncompute these values. We present Silq, the first quantum language that addresses this challenge by supporting safe, automatic uncomputation. This enables an intuitive semantics that implicitly drops temporary values, as in classical computation. To ensure physicality of Silq's semantics, its type system leverages novel annotations to reject unphysical programs. Our experimental evaluation demonstrates that Silq programs are not only easier to read and write, but also significantly shorter than equivalent programs in other quantum languages (on average -46\% for Q\#, -38\% for Quipper), while using only half the number of quantum primitives.},
  keywords = {quantum language, semantics, uncomputation},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Boender2015"></a><pre>
@inproceedings{<a href="bbt.html#Boender2015">Boender2015</a>,
  title = {Formalization of Quantum Protocols using Coq},
  author = {Boender, Jaap and Kamm{\"u}ller, Florian and Nagarajan, Rajagopal},
  year = {2015},
  month = nov,
  booktitle = {Proceedings of the 12th International Workshop on Quantum Physics and Logic (QPL), Oxford, U.K., July 15--17, 2015},
  editor = {Heunen, Chris and Selinger, Peter and Vicary, Jamie},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {195},
  pages = {71--83},
  doi = {10.4204/EPTCS.195.6},
  abstract = {Quantum Information Processing, which is an exciting area of research at the intersection of physics and computer science, has great potential for influencing the future development of information processing systems. The building of practical, general purpose Quantum Computers may be some years into the future. However, Quantum Communication and Quantum Cryptography are well developed. Commercial Quantum Key Distribution systems are easily available and several QKD networks have been built in various parts of the world. The security of the protocols used in these implementations rely on information-theoretic proofs, which may or may not reflect actual system behaviour. Moreover, testing of implementations cannot guarantee the absence of bugs and errors. This paper presents a novel framework for modelling and verifying quantum protocols and their implementations using the proof assistant Coq. We provide a Coq library for quantum bits (qubits), quantum gates, and quantum measurement. As a step towards verifying practical quantum communication and security protocols such as Quantum Key Distribution, we support multiple qubits, communication and entanglement. We illustrate these concepts by modelling the Quantum Teleportation Protocol, which communicates the state of an unknown quantum bit using only a classical channel.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Bordg2020"></a><pre>
@article{<a href="bbt.html#Bordg2020">Bordg2020</a>,
  title = {Isabelle Marries Dirac: a Library for Quantum Computation and Quantum Information},
  author = {Bordg, Anthony and Lachnitt, Hanna and He, Yijun},
  year = {2020},
  month = nov,
  journal = {Archive of Formal Proofs},
  volume = {2020},
  url = {<a href="https://isa-afp.org/entries/Isabelle_Marries_Dirac.html">https://isa-afp.org/entries/Isabelle_Marries_Dirac.html</a>},
  abstract = {This work is an effort to formalise some quantum algorithms and results in quantum information theory. Formal methods being critical for the safety and security of algorithms and protocols, we foresee their widespread use for quantum computing in the future. We have developed a large library for quantum computing in Isabelle based on a matrix representation for quantum circuits, successfully formalising the no-cloning theorem, quantum teleportation, Deutsch's algorithm, the Deutsch-Jozsa algorithm and the quantum Prisoner's Dilemma.},
  webnote = {Formal proof development in Isabelle. Supplement to \cite{Bordg2020a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Bordg2020a"></a><pre>
@article{<a href="bbt.html#Bordg2020a">Bordg2020a</a>,
  title = {Certified Quantum Computation in Isabelle/HOL},
  author = {Bordg, Anthony and Lachnitt, Hanna and He, Yijun},
  year = {2020},
  month = dec,
  journal = {Journal of Automated Reasoning},
  volume = {65},
  number = {5},
  pages = {691--709},
  doi = {10.1007/s10817-020-09584-7},
  url = {<a href="https://www.isa-afp.org/entries/Isabelle_Marries_Dirac.html">https://www.isa-afp.org/entries/Isabelle_Marries_Dirac.html</a>},
  abstract = {In this article we present an ongoing effort to formalise quantum algorithms and results in quantum information theory using the proof assistant Isabelle/HOL. Formal methods being critical for the safety and security of algorithms and protocols, we foresee their widespread use for quantum computing in the future. We have developed a large library for quantum computing in Isabelle based on a matrix representation for quantum circuits, successfully formalising the no-cloning theorem, quantum teleportation, Deutsch's algorithm, the Deutsch--Jozsa algorithm and the quantum Prisoner's Dilemma. We discuss the design choices made and report on an outcome of our work in the field of quantum game theory.},
  keywords = {isabelle/hol, certification, quantum computing, no-cloning, quantum teleportation, deutsch's algorithm, deutsch--jozsa algorithm, quantum prisoner's dilemma},
  webnote = {See also: Isabelle AFP entry \cite{Bordg2020}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Briegel2009"></a><pre>
@article{<a href="bbt.html#Briegel2009">Briegel2009</a>,
  title = {Measurement-Based Quantum Computation},
  author = {Briegel, Hans J. and Browne, Dan E. and D{\"u}r, Wolfgang and Rau{\ss}endorf, Robert and {Van den Nest}, Maarten},
  year = {2009},
  month = jan,
  journal = {Nature Physics},
  volume = {5},
  number = {1},
  pages = {19--26},
  doi = {10.1038/nphys1157},
  archiveprefix = {arXiv},
  eprint = {0910.1116},
  abstract = {Quantum computation offers a promising new kind of information processing, where the non-classical features of quantum mechanics are harnessed and exploited. A number of models of quantum computation exist. These models have been shown to be formally equivalent, but their underlying elementary concepts and the requirements for their practical realization can differ significantly. A particularly exciting paradigm is that of measurement-based quantum computation, where the processing of quantum information takes place by rounds of simple measurements on qubits prepared in a highly entangled state. We review recent developments in measurement-based quantum computation with a view to both fundamental and practical issues, in particular the power of quantum computation, the protection against noise (fault tolerance) and steps towards experimental realization. Finally, we highlight a number of connections between this field and other branches of physics and mathematics.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Chardonnet2021"></a><pre>
@inproceedings{<a href="bbt.html#Chardonnet2021">Chardonnet2021</a>,
  title = {{Geometry of Interaction for ZX-Diagrams}},
  author = {Chardonnet, Kostia and Valiron, Beno{\^i}t and Vilmart, Renaud},
  year = {2021},
  month = aug,
  booktitle = {46th International Symposium on Mathematical Foundations of Computer Science (MFCS 2021)},
  editor = {Bonchi, Filippo and Puglisi, Simon J.},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {202},
  eid = {30},
  pages = {30:1--30:16},
  doi = {10.4230/LIPIcs.MFCS.2021.30},
  url = {<a href="https://hal.archives-ouvertes.fr/hal-03154573/">https://hal.archives-ouvertes.fr/hal-03154573/</a>},
  abstract = {ZX-Calculus is a versatile graphical language for quantum computation equipped with an equational theory. Getting inspiration from Geometry of Interaction, in this paper we propose a token-machine-based asynchronous model of both pure ZX-Calculus and its extension to mixed processes. We also show how to connect this new semantics to the usual standard interpretation of ZX-diagrams. This model allows us to have a new look at what ZX-diagrams compute, and give a more local, operational view of the semantics of ZX-diagrams.},
  keywords = {quantum computation, linear logic, zx-calculus, geometry of interaction},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Chareton2021"></a><pre>
@inproceedings{<a href="bbt.html#Chareton2021">Chareton2021</a>,
  title = {An Automated Deductive Verification Framework for Circuit-Building Quantum Programs},
  author = {Chareton, Christophe and Bardin, S{\'e}bastien and Bobot, Fran{\c c}ois and Perrelle, Valentin and Valiron, Beno{\^i}t},
  year = {2021},
  month = mar,
  booktitle = {Programming Languages and Systems, ESOP 2021},
  editor = {Yoshida, Nobuko},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {12648},
  pages = {148--177},
  doi = {10.1007/978-3-030-72019-3_6},
  archiveprefix = {arXiv},
  eprint = {2003.05841},
  abstract = {While recent progress in quantum hardware open the door for significant speedup in certain key areas, quantum algorithms are still hard to implement right, and the validation of such quantum programs is a challenge. In this paper we propose Qbricks, a formal verification environment for circuit-building quantum programs, featuring both parametric specifications and a high degree of proof automation. We propose a logical framework based on first-order logic, and develop the main tool we rely upon for achieving the automation of proofs of quantum specification: PPS, a parametric extension of the recently developed path sum semantics. To back-up our claims, we implement and verify parametric versions of several famous and non-trivial quantum algorithms, including the quantum parts of Shor's integer factoring, quantum phase estimation (QPE) and Grover's search.},
  keywords = {deductive verification, quantum programming, quantum circuits, sum-over-paths},
  webnote = {See extended version on arXiv for additional technical material.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Chareton2021a"></a><pre>
@misc{<a href="bbt.html#Chareton2021a">Chareton2021a</a>,
  title = {Formal Methods for Quantum Programs: A Survey},
  author = {Chareton, Christophe and Bardin, S{\'e}bastien and Lee, Dongho and Valiron, Beno{\^i}t and Vilmart, Renaud and Xu, Zhaowei},
  year = {2021},
  month = sep,
  archiveprefix = {arXiv},
  eprint = {2109.06493},
  abstract = {While recent progress in quantum hardware open the door for significant speedup in certain key areas (cryptography, biology, chemistry, optimization, machine learning, etc), quantum algorithms are still hard to implement right, and the validation of such quantum programs is a challenge. Moreover, importing the testing and debugging practices at use in classical programming is extremely difficult in the quantum case, due to the destructive aspect of quantum measurement. As an alternative strategy, formal methods are prone to play a decisive role in the emerging field of quantum software. Recent works initiate solutions for problems occurring at every stage of the development process: high-level program design, implementation, compilation, etc. We review the induced challenges for an efficient use of formal methods in quantum computing and the current most promising research directions.},
  note = {To appear as Chapter ``Formal methods for Quantum Algorithms'' in ``Handbook of Formal Analysis and Verification in Cryptography'', CRC},
  webnote = {To appear as Chapter ``Formal methods for Quantum Algorithms'' in ``Handbook of Formal Analysis and Verification in Cryptography'', CRC.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Chong2017"></a><pre>
@article{<a href="bbt.html#Chong2017">Chong2017</a>,
  title = {Programming languages and compiler design for realistic quantum hardware},
  author = {Chong, Frederic T. and Franklin, Diana and Martonosi, Margaret},
  year = {2017},
  month = sep,
  journal = {Nature},
  volume = {549},
  number = {7671},
  pages = {180--187},
  doi = {10.1038/nature23459},
  abstract = {Quantum computing sits at an important inflection point. For years, high-level algorithms for quantum computers have shown considerable promise, and recent advances in quantum device fabrication offer hope of utility. A gap still exists, however, between the hardware size and reliability requirements of quantum computing algorithms and the physical machines foreseen within the next ten years. To bridge this gap, quantum computers require appropriate software to translate and optimize applications (toolflows) and abstraction layers. Given the stringent resource constraints in quantum computing, information passed between layers of software and implementations will differ markedly from in classical computing. Quantum toolflows must expose more physical details between layers, so the challenge is to find abstractions that expose key details while hiding enough complexity.},
  note = {Review Article},
  webnote = {Review Article},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="CirqDevelopers2018"></a><pre>
@misc{<a href="bbt.html#CirqDevelopers2018">CirqDevelopers2018</a>,
  title = {Cirq},
  author = {{Cirq Developers}},
  year = {2018},
  month = jul,
  doi = {10.5281/zenodo.4062499},
  url = {<a href="https://github.com/quantumlib/Cirq">https://github.com/quantumlib/Cirq</a>},
  abstract = {Cirq is a Python library for writing, manipulating, and optimizing quantum circuits and running them against quantum computers and simulators.},
  webnote = {See full list of authors on Github: \url{https://github.com/quantumlib/Cirq/graphs/contributors}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Coecke2011"></a><pre>
@article{<a href="bbt.html#Coecke2011">Coecke2011</a>,
  title = {Interacting Quantum Observables: Categorical Algebra and Diagrammatics},
  shorttitle = {Interacting Quantum Observables},
  author = {Coecke, Bob and Duncan, Ross},
  year = {2011},
  month = apr,
  journal = {New Journal of Physics},
  volume = {13},
  number = {4},
  eid = {043016},
  pages = {043016},
  doi = {10.1088/1367-2630/13/4/043016},
  abstract = {This paper has two tightly intertwined aims: (i) to introduce an intuitive and universal graphical calculus for multi-qubit systems, the ZX-calculus, which greatly simplifies derivations in the area of quantum computation and information. (ii) To axiomatize complementarity of quantum observables within a general framework for physical theories in terms of dagger symmetric monoidal categories. We also axiomatize phase shifts within this framework. Using the well-studied canonical correspondence between graphical calculi and dagger symmetric monoidal categories, our results provide a purely graphical formalisation of complementarity for quantum observables. Each individual observable, represented by a commutative special dagger Frobenius algebra, gives rise to an Abelian group of phase shifts, which we call the phase group. We also identify a strong form of complementarity, satisfied by the Z- and X-spin observables, which yields a scaled variant of a bialgebra.},
  keywords = {zx-calculus},
  webnote = {Corrects several errors in and supersedes the earlier ICALP 2008 conference paper.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Coecke2017"></a><pre>
@book{<a href="bbt.html#Coecke2017">Coecke2017</a>,
  title = {Picturing Quantum Processes: A First Course in Quantum Theory and Diagrammatic Reasoning},
  author = {Coecke, Bob and Kissinger, Aleks},
  year = {2017},
  month = mar,
  booktitle = {Picturing Quantum Processes: A First Course in Quantum Theory and Diagrammatic Reasoning},
  publisher = {{Cambridge University Press}},
  address = {Cambridge},
  doi = {10.1017/9781316219317},
  abstract = {The unique features of the quantum world are explained in this book through the language of diagrams, setting out an innovative visual method for presenting complex theories. Requiring only basic mathematical literacy, this book employs a unique formalism that builds an intuitive understanding of quantum features while eliminating the need for complex calculations. This entirely diagrammatic presentation of quantum theory represents the culmination of ten years of research, uniting classical techniques in linear algebra and Hilbert spaces with cutting-edge developments in quantum computation and foundations. Written in an entertaining and user-friendly style and including more than one hundred exercises, this book is an ideal first course in quantum theory, foundations, and computation for students from undergraduate to PhD level, as well as an opportunity for researchers from a broad range of fields, from physics to biology, linguistics, and cognitive science, to discover a new set of tools for studying processes and interaction.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Colledan2022"></a><pre>
@misc{<a href="bbt.html#Colledan2022">Colledan2022</a>,
  title = {{On Dynamic Lifting and Effect Typing in Circuit Description Languages (Extended Version)}},
  author = {Colledan, Andrea and Dal Lago, Ugo},
  year = {2022},
  month = feb,
  archiveprefix = {arXiv},
  eprint = {2202.07636},
  abstract = {In the realm of quantum computing, circuit description languages represent a valid alternative to traditional QRAM-style languages. They indeed allow for finer control over the output circuit, without sacrificing flexibility nor modularity. We introduce a generalization of the paradigmatic lambda-calculus Proto-Quipper-M, itself modeling the core features of the quantum circuit description language Quipper. The extension, called Proto-Quipper-K, is meant to capture a very general form of dynamic lifting. This is made possible by the introduction of a rich type and effect system in which not only computations, but also the very types are effectful. The main results we give for the introduced language are the classic type soundness results, namely subject reduction and progress.},
  keywords = {proto-quipper-k, proto-quipper-m, dynamic lifting},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Cross2017"></a><pre>
@misc{<a href="bbt.html#Cross2017">Cross2017</a>,
  title = {Open {{Quantum Assembly Language}}},
  author = {Cross, Andrew W. and Bishop, Lev S. and Smolin, John A. and Gambetta, Jay M.},
  year = {2017},
  month = jul,
  archiveprefix = {arXiv},
  eprint = {1707.03429},
  url = {<a href="https://github.com/Qiskit/openqasm/tree/OpenQASM2.x">https://github.com/Qiskit/openqasm/tree/OpenQASM2.x</a>},
  abstract = {This document describes a quantum assembly language (QASM) called OpenQASM that is used to implement experiments with low depth quantum circuits. OpenQASM represents universal physical circuits over the CNOT plus SU(2) basis with straight-line code that includes measurement, reset, fast feedback, and gate subroutines. The simple text language can be written by hand or by higher level tools and may be executed on the IBM Q Experience.},
  keywords = {qasm, quantum assembly language, openqasm, quantum computing, quantum information},
  webnote = {OpenQASM 2.0, see \cite{Cross2022} for OpenQASM 3},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Cross2022"></a><pre>
@article{<a href="bbt.html#Cross2022">Cross2022</a>,
  title = {OpenQASM 3: A Broader and Deeper Quantum Assembly Language},
  author = {Cross, Andrew W. and Javadi-Abhari, Ali and Alexander, Thomas and de Beaudrap, Niel and Bishop, Lev S. and Heidel, Steven and Ryan, Colm A. and Sivarajah, Prasahnt and Smolin, John and Gambetta, Jay M. and Johnson, Blake R.},
  year = {2022},
  month = sep,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  volume = {3},
  number = {3},
  eid = {12},
  pages = {12},
  numpages = {50},
  doi = {10.1145/3505636},
  archiveprefix = {arXiv},
  eprint = {2104.14722},
  url = {<a href="https://openqasm.com/">https://openqasm.com/</a>},
  abstract = {Quantum assembly languages are machine-independent languages that traditionally describe quantum computation in the circuit model. Open quantum assembly language (OpenQASM 2) was proposed as an imperative programming language for quantum circuits based on earlier QASM dialects. In principle, any quantum computation could be described using OpenQASM 2, but there is a need to describe a broader set of circuits beyond the language of qubits and gates. By examining interactive use cases, we recognize two different timescales of quantum-classical interactions: real-time classical computations that must be performed within the coherence times of the qubits, and near-time computations with less stringent timing. Since the near-time domain is adequately described by existing programming frameworks, we choose in OpenQASM 3 to focus on the real-time domain, which must be more tightly coupled to the execution of quantum operations. We add support for arbitrary control flow as well as calling external classical functions. In addition, we recognize the need to describe circuits at multiple levels of specificity, and therefore we extend the language to include timing, pulse control, and gate modifiers. These new language features create a multi-level intermediate representation for circuit development and optimization, as well as control sequence implementation for calibration, characterization, and error mitigation.},
  keywords = {qasm, quantum assembly language, openqasm, quantum computing, quantum information},
  webnote = {See \cite{Cross2017} for OpenQASM 2.0},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="DalLago2017"></a><pre>
@inproceedings{<a href="bbt.html#DalLago2017">DalLago2017</a>,
  title = {The Geometry of Parallelism: Classical, Probabilistic, and Quantum Effects},
  author = {{Dal Lago}, Ugo and Faggian, Claudia and Valiron, Beno{\^i}t and Yoshimizu, Akira},
  year = {2017},
  month = jan,
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {POPL '17},
  pages = {833--845},
  doi = {10.1145/3009837.3009859},
  archiveprefix = {arXiv},
  eprint = {1610.09629},
  abstract = {We introduce a Geometry of Interaction model for higher-order quantum computation, and prove its adequacy for a fully fledged quantum programming language in which entanglement, duplication, and recursion are all available. This model is an instance of a new framework which captures not only quantum but also classical and probabilistic computation. Its main feature is the ability to model commutative effects in a parallel setting. Our model comes with a multi-token machine, a proof net system, and a -style language. Being based on a multi-token machine equipped with a memory, it has a concrete nature which makes it well suited for building low-level operational descriptions of higher-order languages.},
  keywords = {memory structure, geometry of interaction, quantum computation, lambda calculus, probabilistic computation},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Dandy2021"></a><pre>
@misc{<a href="bbt.html#Dandy2021">Dandy2021</a>,
  title = {Qimaera: Type-safe (Variational) Quantum Programming in Idris},
  author = {Dandy, Liliane-Joy and Jeandel, Emmanuel and Zamdzhiev, Vladimir},
  year = {2021},
  month = nov,
  archiveprefix = {arXiv},
  eprint = {2111.10867},
  url = {<a href="https://github.com/zamdzhiev/Qimaera">https://github.com/zamdzhiev/Qimaera</a>},
  abstract = {Variational Quantum Algorithms are hybrid classical-quantum algorithms where classical and quantum computation work in tandem to solve computational problems. These algorithms create interesting challenges for the design of suitable programming languages. In this paper we introduce Qimaera, which is a set of libraries for the Idris 2 programming language that enable the programmer to implement (variational) quantum algorithms where the full power of the elegant Idris language works in synchrony with quantum programming primitives that we introduce. The two key ingredients of Idris that make this possible are (1) dependent types which allow us to implement unitary (i.e. reversible and controllable) quantum operations; and (2) linearity which allows us to enforce fine-grained control over the execution of quantum operations that ensures compliance with the laws of quantum mechanics. We demonstrate that Qimaera is suitable for variational quantum programming by providing implementations of the two most prominent variational quantum algorithms -- QAOA and VQE. To the best of our knowledge, this is the first implementation of these algorithms that has been achieved in a type-safe framework.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Danos2007"></a><pre>
@article{<a href="bbt.html#Danos2007">Danos2007</a>,
  title = {The {{Measurement Calculus}}},
  author = {Danos, Vincent and Kashefi, Elham and Panangaden, Prakash},
  year = {2007},
  month = apr,
  journal = {Journal of the ACM},
  volume = {54},
  number = {2},
  eid = {8},
  pages = {8},
  numpages = {45},
  doi = {10.1145/1219092.1219096},
  url = {<a href="https://www.cs.mcgill.ca/~prakash/Pubs/jacm.pdf">https://www.cs.mcgill.ca/~prakash/Pubs/jacm.pdf</a>},
  abstract = {Measurement-based quantum computation has emerged from the physics community as a new approach to quantum computation where the notion of measurement is the main driving force of computation. This is in contrast with the more traditional circuit model that is based on unitary operations. Among measurement-based quantum computation methods, the recently introduced one-way quantum computer [Raussendorf and Briegel 2001] stands out as fundamental. We develop a rigorous mathematical model underlying the one-way quantum computer and present a concrete syntax and operational semantics for programs, which we call patterns, and an algebra of these patterns derived from a denotational semantics. More importantly, we present a calculus for reasoning locally and compositionally about these patterns. We present a rewrite theory and prove a general standardization theorem which allows all patterns to be put in a semantically equivalent standard form. Standardization has far-reaching consequences: a new physical architecture based on performing all the entanglement in the beginning, parallelization by exposing the dependency structure of measurements and expressiveness theorems. Furthermore we formalize several other measurement-based models, for example, Teleportation, Phase and Pauli models and present compositional embeddings of them into and from the one-way model. This allows us to transfer all the theory we develop for the one-way model to these models. This shows that the framework we have developed has a general impact on measurement-based computation and is not just particular to the one-way quantum computer.},
  keywords = {normalization, measurement-based quantum computing, quantum programming languages, models for quantum computing, term rewriting, teleportation-based quantum computing},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Danos2009"></a><pre>
@incollection{<a href="bbt.html#Danos2009">Danos2009</a>,
  title = {Extended {{Measurement Calculus}}},
  author = {Danos, Vincent and Kashefi, Elham and Panangaden, Prakash and Perdrix, Simon},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  pages = {235--310},
  crossref = {<a href="#Gay2009">Gay2009</a>},
  doi = {10.1017/CBO9781139193313.008},
  abstract = {Measurement-based quantum computation (MBQC) has emerged as a new approach to quantum computation where the notion of measurement is the main driving force of computation. This is in contrast with the more traditional circuit model that takes unitary operations as fundamental. Among measurement-based quantum computation methods the recently introduced one-way quantum computer stands out as basic and fundamental. The key idea is to start from an entangled state and then use measurements and one-qubit unitaries, which may be dependent on the outcomes of measurements, to guide the computation. The main point is that one never has to perform unitaries on more than one qubit at a time after the initial preparation of an entangled state. The ``programs'' that one writes in this model are traditionally called ``patterns''. In this chapter, we develop a rigorous mathematical model underlying measurement-based quantum computation. We give syntax, operational semantics, denotational semantics, and an algebra of programs derived from the denotational semantics. We also present a rewrite theory and prove a general standardization theorem that allows all programs to be put in a semantically equivalent standard form. Standardization has far-reaching consequences: a new physical architecture based on performing all the entanglement in the beginning, parallelization by exposing the dependency structure of measurements, and expressiveness theorems.We use our general measurement calculus not just to formalize the one-way model but also several other measurement-based models, e.g., Teleportation, Phase, and Pauli models, and present compositional embeddings of them into and from the one-way model.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="DHondt2006"></a><pre>
@article{<a href="bbt.html#DHondt2006">DHondt2006</a>,
  title = {Quantum {{Weakest Preconditions}}},
  author = {D'Hondt, Ellie and Panangaden, Prakash},
  year = {2006},
  month = jun,
  journal = {Mathematical Structures in Computer Science},
  volume = {16},
  number = {3},
  pages = {429--451},
  doi = {10.1017/S0960129506005251},
  url = {<a href="https://www.cs.mcgill.ca/~prakash/Pubs/weakest_mscs.pdf">https://www.cs.mcgill.ca/~prakash/Pubs/weakest_mscs.pdf</a>},
  abstract = {We develop a notion of predicate transformer and, in particular, the weakest precondition, appropriate for quantum computation. We show that there is a Stone-type duality between the usual state-transformer semantics and the weakest precondition semantics. Rather than trying to reduce quantum computation to probabilistic programming, we develop a notion that is directly taken from concepts used in quantum computation. The proof that weakest preconditions exist for completely positive maps follows immediately from the Kraus representation theorem. As an example, we give the semantics of Selinger's language in terms of our weakest preconditions. We also cover some specific situations and exhibit an interesting link with stabilisers.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Echenim2021"></a><pre>
@misc{<a href="bbt.html#Echenim2021">Echenim2021</a>,
  title = {Quantum projective measurements and the {CHSH} inequality in Isabelle/HOL},
  author = {Echenim, Mnacho and Mhalla, Mehdi},
  year = {2021},
  month = mar,
  archiveprefix = {arXiv},
  eprint = {2103.08535},
  abstract = {We present a formalization in Isabelle/HOL of quantum projective measurements, a class of measurements involving orthogonal projectors that is frequently used in quantum computing. We also formalize the CHSH inequality, a result that holds on arbitrary probability spaces, which can used to disprove the existence of a local hidden-variable theory for quantum mechanics.},
  webnote = {See also: Isabelle AFP entry \cite{Echenim2021a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Echenim2021a"></a><pre>
@article{<a href="bbt.html#Echenim2021a">Echenim2021a</a>,
  title = {Quantum projective measurements and the CHSH inequality},
  author = {Echenim, Mnacho},
  year = {2021},
  month = mar,
  journal = {Archive of Formal Proofs},
  volume = {2021},
  url = {<a href="https://isa-afp.org/entries/Projective_Measurements.html">https://isa-afp.org/entries/Projective_Measurements.html</a>},
  abstract = {This work contains a formalization of quantum projective measurements, also known as von Neumann measurements, which are based on elements of spectral theory. We also formalized the CHSH inequality, an inequality involving expectations in a probability space that is violated by quantum measurements, thus proving that quantum mechanics cannot be modeled with an underlying local hidden-variable theory.},
  webnote = {Formal proof development in Isabelle, supplement to \cite{Echenim2021}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Feng2021"></a><pre>
@article{<a href="bbt.html#Feng2021">Feng2021</a>,
  title = {Quantum Hoare Logic with Classical Variables},
  author = {Feng, Yuan and Ying, Mingsheng},
  year = {2021},
  month = dec,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  volume = {2},
  number = {4},
  eid = {16},
  pages = {16},
  numpages = {43},
  doi = {10.1145/3456877},
  archiveprefix = {arXiv},
  eprint = {2008.06812},
  abstract = {Hoare logic provides a syntax-oriented method to reason about program correctness and has been proven effective in the verification of classical and probabilistic programs. Existing proposals for quantum Hoare logic either lack completeness or support only quantum variables, thus limiting their capability in practical use. In this article, we propose a quantum Hoare logic for a simple while language that involves both classical and quantum variables. Its soundness and relative completeness are proven for both partial and total correctness of quantum programs written in the language. Remarkably, with novel definitions of classical-quantum states and corresponding assertions, the logic system is quite simple and similar to the traditional Hoare logic for classical programs. Furthermore, to simplify reasoning in real applications, auxiliary proof rules are provided that support standard logical operation in the classical part of assertions and super-operator application in the quantum part. Finally, a series of practical quantum algorithms, in particular the whole algorithm of Shor's factorisation, are formally verified to show the effectiveness of the logic.},
  keywords = {quantum while language, quantum programming, hoare logic},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Feng2022"></a><pre>
@article{<a href="bbt.html#Feng2022">Feng2022</a>,
  title = {Verification of Distributed Quantum Programs},
  author = {Feng, Yuan and Li, Sanjiang and Ying, Mingsheng},
  year = {2022},
  month = jul,
  journal = {ACM Transactions on Computational Logic},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {23},
  number = {3},
  eid = {19},
  pages = {19},
  doi = {10.1145/3517145},
  archiveprefix = {arXiv},
  eprint = {2104.14796},
  abstract = {Distributed quantum systems and especially the Quantum Internet have the ever-increasing potential to fully demonstrate the power of quantum computation. This is particularly true given that developing a general-purpose quantum computer is much more difficult than connecting many small quantum devices. One major challenge of implementing distributed quantum systems is programming them and verifying their correctness. In this paper, we propose a CSP-like distributed programming language to facilitate the specification and verification of such systems. After presenting its operational and denotational semantics, we develop a Hoare-style logic for distributed quantum programs and establish its soundness and (relative) completeness with respect to both partial and total correctness. The effectiveness of the logic is demonstrated by its applications in the verification of quantum teleportation and local implementation of non-local CNOT gates, two important algorithms widely used in distributed quantum systems.},
  keywords = {distributed computing, quantum programming, formal verification, hoare logic},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Fu2020"></a><pre>
@inproceedings{<a href="bbt.html#Fu2020">Fu2020</a>,
  title = {Linear {{Dependent Type Theory}} for {{Quantum Programming Languages}}: {{Extended Abstract}}},
  shorttitle = {Linear {{Dependent Type Theory}} for {{Quantum Programming Languages}}},
  author = {Fu, Peng and Kishida, Kohei and Selinger, Peter},
  year = {2020},
  month = jul,
  booktitle = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{LICS}} '20},
  pages = {440--453},
  doi = {10.1145/3373718.3394765},
  abstract = {Modern quantum programming languages integrate quantum resources and classical control. They must, on the one hand, be linearly typed to reflect the no-cloning property of quantum resources. On the other hand, high-level and practical languages should also support quantum circuits as first-class citizens, as well as families of circuits that are indexed by some classical parameters. Quantum programming languages thus need linear dependent type theory. This paper defines a general semantic structure for such a type theory via certain fibrations of monoidal categories. The categorical model of the quantum circuit description language Proto-Quipper-M by Rios & Selinger constitutes an example of such a fibration, which means that the language can readily be integrated with dependent types. We then devise both a general linear dependent type system and a dependently typed extension of Proto-Quipper-M, and provide them with operational semantics as well as a prototype implementation.},
  keywords = {proto-quipper-d, fibration, categorical model, quantum programming languages, linear dependent types, proto-quipper-m},
  webnote = {See expanded version at \cite{Fu2022b}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Fu2020a"></a><pre>
@inproceedings{<a href="bbt.html#Fu2020a">Fu2020a</a>,
  title = {A Tutorial Introduction to Quantum Circuit Programming in Dependently Typed Proto-Quipper},
  author = {Fu, Peng and Kishida, Kohei and Ross, Neil J. and Selinger, Peter},
  year = {2020},
  month = jul,
  booktitle = {Reversible Computation (RC '20)},
  editor = {Lanese, Ivan and Rawski, Mariusz},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {12227},
  pages = {153--168},
  doi = {10.1007/978-3-030-52482-1_9},
  archiveprefix = {arXiv},
  eprint = {2005.08396},
  abstract = {We introduce dependently typed Proto-Quipper, or Proto-Quipper-D for short, an experimental quantum circuit programming language with linear dependent types. We give several examples to illustrate how linear dependent types can help in the construction of correct quantum circuits. Specifically, we show how dependent types enable programming families of circuits, and how dependent types solve the problem of type-safe uncomputation of garbage qubits. We also discuss other language features along the way.},
  keywords = {quantum programming languages, linear dependent types, proto-quipper-d},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Fu2022"></a><pre>
@article{<a href="bbt.html#Fu2022">Fu2022</a>,
  title = {Proto-Quipper with dynamic lifting},
  author = {Fu, Peng and Kishida, Kohei and Ross, Neil J. and Selinger, Peter},
  year = {2022},
  month = apr,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {POPL},
  eid = {},
  pages = {},
  doi = {},
  archiveprefix = {arXiv},
  eprint = {2204.13041},
  url = {<a href="https://gitlab.com/frank-peng-fu/dpq-remake">https://gitlab.com/frank-peng-fu/dpq-remake</a>},
  abstract = {Quipper is a functional programming language for quantum computing. Proto-Quipper is a family of languages aiming to provide a formal foundation for Quipper. In this paper, we extend Proto-Quipper-M with a construct called dynamic lifting, which is present in Quipper. By virtue of being a circuit description language, Proto-Quipper has two separate runtimes: circuit generation time and circuit execution time. Values that are known at circuit generation time are called parameters, and values that are known at circuit execution time are called states. Dynamic lifting is an operation that enables a state, such as the result of a measurement, to be lifted to a parameter, where it can influence the generation of the next portion of the circuit. As a result, dynamic lifting enables Proto-Quipper programs to interleave classical and quantum computation. We describe the syntax of a language we call Proto-Quipper-Dyn. Its type system uses a system of modalities to keep track of the use of dynamic lifting. We also provide an operational semantics, as well as an abstract categorical semantics for dynamic lifting based on enriched category theory. We prove that both the type system and the operational semantics are sound with respect to our categorical semantics. Finally, we give some examples of Proto-Quipper-Dyn programs that make essential use of dynamic lifting. A concrete categorical model is given in a companion paper [FKRS2022b].},
  keywords = {proto-quipper-dyn, proto-quipper-m, proto-quipper, quipper},
  note = {To appear at POPL '23.},
  webnote = {To appear at POPL '23. See the companion paper \cite{Fu2022a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Fu2022a"></a><pre>
@misc{<a href="bbt.html#Fu2022a">Fu2022a</a>,
  title = {A biset-enriched categorical model for Proto-Quipper with dynamic lifting},
  author = {Fu, Peng and Kishida, Kohei and Ross, Neil J. and Selinger, Peter},
  year = {2022},
  month = apr,
  archiveprefix = {arXiv},
  eprint = {2204.13039},
  abstract = {Quipper and Proto-Quipper are a family of quantum programming languages that, by their nature as circuit description languages, involve two runtimes: one at which the program generates a circuit and one at which the circuit is executed, normally with probabilistic results due to measurements. Accordingly, the language distinguishes two kinds of data: parameters, which are known at circuit generation time, and states, which are known at circuit execution time. Sometimes, it is desirable for the results of measurements to control the generation of the next part of the circuit. Therefore, the language needs to turn states, such as measurement outcomes, into parameters, an operation we call dynamic lifting. The goal of this paper is to model this interaction between the runtimes by providing a general categorical structure enriched in what we call "bisets". We demonstrate that the biset-enriched structure achieves a proper semantics of the two runtimes and their interaction, by showing that it models a variant of Proto-Quipper with dynamic lifting. The present paper deals with the concrete categorical semantics of this language, whereas a companion paper [FKRS2022a] deals with the syntax, type system, operational semantics, and abstract categorical semantics.},
  keywords = {proto-quipper-dyn, proto-quipper, quipper, categorical semantics},
  webnote = {See the companion paper \cite{Fu2022}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Fu2022b"></a><pre>
@article{<a href="bbt.html#Fu2022b">Fu2022b</a>,
  title = {{Linear Dependent Type Theory for Quantum Programming Languages}},
  author = {Fu, Peng and Kishida, Kohei and Selinger, Peter},
  year = {2022},
  month = sep,
  journal = {Logical Methods in Computer Science},
  volume = {18},
  number = {3},
  eid = {28},
  pages = {28},
  doi = {10.46298/lmcs-18(3:28)2022},
  abstract = {Modern quantum programming languages integrate quantum resources and classical control. They must, on the one hand, be linearly typed to reflect the no-cloning property of quantum resources. On the other hand, high-level and practical languages should also support quantum circuits as first-class citizens, as well as families of circuits that are indexed by some classical parameters. Quantum programming languages thus need linear dependent type theory. This paper defines a general semantic structure for such a type theory via certain fibrations of monoidal categories. The categorical model of the quantum circuit description language Proto-Quipper-M by Rios and Selinger (2017) constitutes an example of such a fibration, which means that the language can readily be integrated with dependent types. We then devise both a general linear dependent type system and a dependently typed extension of Proto-Quipper-M, and provide them with operational semantics as well as a prototype implementation.},
  keywords = {proto-quipper-d, fibration, categorical model, quantum programming languages, linear dependent types, proto-quipper-m},
  webnote = {Expanded version of \cite{Fu2020}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Gay2005"></a><pre>
@inproceedings{<a href="bbt.html#Gay2005">Gay2005</a>,
  title = {Communicating Quantum Processes},
  author = {Gay, Simon J. and Nagarajan, Rajagopal},
  year = {2005},
  month = jan,
  booktitle = {Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{POPL}} '05},
  pages = {145--157},
  doi = {10.1145/1040305.1040318},
  archiveprefix = {arXiv},
  eprint = {quant-ph/0409052},
  url = {<a href="http://www.dcs.gla.ac.uk/~simon/publications/CQP-POPL.pdf">http://www.dcs.gla.ac.uk/~simon/publications/CQP-POPL.pdf</a>},
  abstract = {We define a language CQP (Communicating Quantum Processes) for modelling systems which combine quantum and classical communication and computation. CQP combines the communication primitives of the pi-calculus with primitives for measurement and transformation of quantum state; in particular, quantum bits (qubits) can be transmitted from process to process along communication channels. CQP has a static type system which classifies channels, distinguishes between quantum and classical data, and controls the use of quantum state. We formally define the syntax, operational semantics and type system of CQP, prove that the semantics preserves typing, and prove that typing guarantees that each qubit is owned by a unique process within a system. We illustrate CQP by defining models of several quantum communication systems, and outline our plans for using CQP as the foundation for formal analysis and verification of combined quantum and classical systems.},
  keywords = {quantum computing, semantics, verification, types, quantum communication, formal language},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Gay2006"></a><pre>
@article{<a href="bbt.html#Gay2006">Gay2006</a>,
  title = {Quantum Programming Languages: Survey and Bibliography},
  author = {Gay, Simon J.},
  year = {2006},
  month = aug,
  journal = {Mathematical Structures in Computer Science},
  volume = {16},
  number = {4},
  pages = {581--600},
  doi = {10.1017/S0960129506005378},
  url = {<a href="http://www.dcs.gla.ac.uk/~simon/quantum/">http://www.dcs.gla.ac.uk/~simon/quantum/</a>},
  abstract = {The field of quantum programming languages is developing rapidly and there is a surprisingly large literature. Research in this area includes the design of programming languages for quantum computing, the application of established semantic and logical techniques to the foundations of quantum mechanics, and the design of compilers for quantum programming languages. This article justifies the study of quantum programming languages, presents the basics of quantum computing, surveys the literature in quantum programming languages, and indicates directions for future research.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Gay2008"></a><pre>
@inproceedings{<a href="bbt.html#Gay2008">Gay2008</a>,
  title = {QMC: A Model Checker for Quantum Systems},
  author = {Gay, Simon J. and Nagarajan, Rajagopal and Papanikolaou, Nikolaos},
  year = {2008},
  month = jul,
  booktitle = {Computer Aided Verification (CAV '08)},
  editor = {Gupta, Aarti and Malik, Sharad},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  volume = {5123},
  pages = {543--547},
  doi = {10.1007/978-3-540-70545-1_51},
  archiveprefix = {arXiv},
  eprint = {0704.3705},
  abstract = {The novel field of quantum computation and quantum information has been growing at a rapid rate; the study of quantum information in particular has led to the emergence of communication and cryptographic protocols with no classical analogues. Quantum information protocols have interesting properties which are not exhibited by their classical counterparts, but they are most distinguished for their applications in cryptography. Notable results include the unconditional security proof [1] of quantum key distribution. This result, in particular, is one of the reasons for the widespread interest in this field. Furthermore, the implementation of quantum cryptography has been demonstrated in non-laboratory settings and is already an important practical technology. Implementations of quantum cryptography have already been commercially launched and tested by a number of companies including MagiQ, Id Quantique, Toshiba, and NEC. The unconditional security of quantum key distribution protocols does not automatically imply the same degree of security for actual systems, of course; this justifies the need for systems modelling and verification in this setting.},
  webnote = {Tool paper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Gay2009"></a><pre>
@book{<a href="bbt.html#Gay2009">Gay2009</a>,
  title = {Semantic Techniques in Quantum Computation},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {Cambridge},
  doi = {10.1017/CBO9781139193313},
  abstract = {The study of computational processes based on the laws of quantum mechanics has led to the discovery of new algorithms, cryptographic techniques, and communication primitives. This book explores quantum computation from the perspective of the branch of theoretical computer science known as semantics, as an alternative to the more well-known studies of algorithmics, complexity theory, and information theory. It collects chapters from leading researchers in the field, discussing the theory of quantum programming languages, logics and tools for reasoning about quantum systems, and novel approaches to the foundations of quantum mechanics. This book is suitable for graduate students and researchers in quantum information and computation, as well as those in semantics, who want to learn about a new field arising from the application of semantic techniques to quantum information and computation.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Gheorghiu2018"></a><pre>
@article{<a href="bbt.html#Gheorghiu2018">Gheorghiu2018</a>,
  title = {Quantum++: A modern C++ quantum computing library},
  author = {Gheorghiu, Vlad},
  year = {2018},
  month = dec,
  journal = {{PLoS ONE}},
  publisher = {{Public Library of Science}},
  volume = {13},
  number = {12},
  eid = {e0208073},
  pages = {e0208073},
  numpages = {27},
  doi = {10.1371/journal.pone.0208073},
  url = {<a href="https://github.com/softwareQinc/qpp">https://github.com/softwareQinc/qpp</a>},
  abstract = {Quantum++ is a modern general-purpose multi-threaded quantum computing library written in C++11 and composed solely of header files. The library is not restricted to qubit systems or specific quantum information processing tasks, being capable of simulating arbitrary quantum processes. The main design factors taken in consideration were the ease of use, portability, and performance. The library's simulation capabilities are only restricted by the amount of available physical memory. On a typical machine (Intel i5 8Gb RAM) Quantum++ can successfully simulate the evolution of 25 qubits in a pure state or of 12 qubits in a mixed state reasonably fast. The library also includes support for classical reversible logic, being able to simulate classical reversible operations on billions of bits. This latter feature may be useful in testing quantum circuits composed solely of Toffoli gates, such as certain arithmetic circuits.},
  keywords = {quantum computing, libraries, logic circuits, open source software},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Grattage2011"></a><pre>
@inproceedings{<a href="bbt.html#Grattage2011">Grattage2011</a>,
  title = {An Overview of QML With a Concrete Implementation in Haskell},
  author = {Grattage, Jonathan},
  year = {2011},
  month = feb,
  booktitle = {Proceedings of the Joint 5th International Workshop on Quantum Physics and Logic and 4th Workshop on Developments in Computational Models (QPL/DCM 2008)},
  publisher = {Elsevier},
  series = {Electronic Notes in Theoretical Computer Science},
  volume = {270},
  pages = {165--174},
  doi = {10.1016/j.entcs.2011.01.015},
  archiveprefix = {arXiv},
  eprint = {0806.2735},
  abstract = {This paper gives an introduction to and overview of the functional quantum programming language QML. The syntax of this language is defined and explained, along with a new QML definition of the quantum teleport algorithm. The categorical operational semantics of QML is also briefly introduced, in the form of annotated quantum circuits. This definition leads to a denotational semantics, given in terms of superoperators. Finally, an implementation in Haskell of the semantics for QML is presented as a compiler. The compiler takes QML programs as input, which are parsed into a Haskell datatype. The output from the compiler is either a quantum circuit (operational), an isometry (pure denotational) or a superoperator (impure denotational). Orthogonality judgements and problems with coproducts in QML are also discussed.},
  webnote = {See \cite{Altenkirch2005} for original description of QML},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Green2010"></a><pre>
@phdthesis{<a href="bbt.html#Green2010">Green2010</a>,
  title = {Towards a Formally Verified Functional Quantum Programming Language},
  author = {Green, Alexander S.},
  year = {2010},
  month = jul,
  school = {University of Nottingham},
  url = {<a href="http://eprints.nottingham.ac.uk/11457/">http://eprints.nottingham.ac.uk/11457/</a>},
  abstract = {This thesis looks at the development of a framework for a functional quantum programming language. The framework is first developed in Haskell, looking at how a monadic structure can be used to explicitly deal with the side-effects inherent in the measurement of quantum systems, and goes on to look at how a dependently-typed reimplementation in Agda gives us the basis for a formally verified quantum programming language. The two implementations are not in themselves fully developed quantum programming languages, as they are embedded in their respective parent languages, but are a major step towards the development of a full formally verified, functional quantum programming language. Dubbed the ``Quantum IO Monad'', this framework is designed following a structural approach as given by a categorical model of quantum computation.},
  keywords = {quantum programming, haskell, monadic structure, quantum io monad},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Green2013"></a><pre>
@inproceedings{<a href="bbt.html#Green2013">Green2013</a>,
  title = {Quipper: {{A Scalable Quantum Programming Language}}},
  shorttitle = {Quipper},
  author = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2013},
  month = jun,
  booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{PLDI}} '13},
  pages = {333--342},
  doi = {10.1145/2491956.2462177},
  archiveprefix = {arXiv},
  eprint = {1304.3390},
  abstract = {The field of quantum algorithms is vibrant. Still, there is currently a lack of programming languages for describing quantum computation on a practical scale, i.e., not just at the level of toy problems. We address this issue by introducing Quipper, a scalable, expressive, functional, higher-order quantum programming language. Quipper has been used to program a diverse set of non-trivial quantum algorithms, and can generate quantum gate representations using trillions of gates. It is geared towards a model of computation that uses a classical computer to control a quantum device, but is not dependent on any particular model of quantum hardware. Quipper has proven effective and easy to use, and opens the door towards using formal methods to analyze quantum algorithms.},
  keywords = {quipper, quantum programming languages},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Green2013a"></a><pre>
@inproceedings{<a href="bbt.html#Green2013a">Green2013a</a>,
  title = {An {{Introduction}} to {{Quantum Programming}} in {{Quipper}}},
  author = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2013},
  month = jul,
  booktitle = {Reversible Computation (RC '13)},
  editor = {Dueck, Gerhard W. and Miller, D. Michael},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  series = {Lecture Notes in Computer Science},
  volume = {7948},
  pages = {110--124},
  doi = {10.1007/978-3-642-38986-3_10},
  archiveprefix = {arXiv},
  eprint = {1304.5485},
  abstract = {Quipper is a recently developed programming language for expressing quantum computations. This paper gives a brief tutorial introduction to the language, through a demonstration of how to make use of some of its key features. We illustrate many of Quipper's language features by developing a few well known examples of Quantum computation, including quantum teleportation, the quantum Fourier transform, and a quantum circuit for addition.},
  keywords = {quantum computation, programming languages, quipper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Haner2022"></a><pre>
@misc{<a href="bbt.html#Haner2022">Haner2022</a>,
  title = {QParallel: Explicit Parallelism for Programming Quantum Computers},
  author = {H{\"a}ner, Thomas and Kliuchnikov, Vadym and Roetteler, Martin and Soeken, Mathias and Vaschillo, Alexander},
  year = {2022},
  month = oct,
  archiveprefix = {arXiv},
  eprint = {2210.03680},
  abstract = {We present a language extension for parallel quantum programming to (1) remove ambiguities concerning parallelism in current quantum programming languages and (2) facilitate space-time tradeoff investigations in quantum computing. While the focus of similar libraries in the domain of classical computing (OpenMP, OpenACC, etc.) is to divide a computation into multiple threads, the main goal of QParallel is to keep the compiler and the runtime system from introducing parallelism-inhibiting dependencies, e.g., through reuse of qubits in automatic qubit management. We describe the syntax and semantics of the proposed language extension, implement a prototype based on Q\#, and present several examples and use cases to illustrate its performance benefits. Moreover, we introduce a tool that guides programmers in the placement of parallel regions by identifying the subroutines that profit most from parallelization, which is especially useful if the programmer's knowledge of the source code is limited. Support for QParallel can be added to any multithreading library and language extension, including OpenMP and OpenACC.},
  keywords = {quantum computing, parallel quantum computing, space-time tradeoffs},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Hasuo2017"></a><pre>
@article{<a href="bbt.html#Hasuo2017">Hasuo2017</a>,
  title = {Semantics of higher-order quantum computation via geometry of interaction},
  author = {Hasuo, Ichiro and Hoshino, Naohiko},
  year = {2017},
  month = feb,
  journal = {Annals of Pure and Applied Logic},
  volume = {168},
  number = {2},
  pages = {404--469},
  doi = {10.1016/j.apal.2016.10.010},
  archiveprefix = {arXiv},
  eprint = {1605.05079},
  abstract = {While much of the current study on quantum computation employs low-level formalisms such as quantum circuits, several high-level languages/calculi have been recently proposed aiming at structured quantum programming. The current work contributes to the semantical study of such languages by providing interaction-based semantics of a functional quantum programming language; the latter is, much like Selinger and Valiron's, based on linear lambda calculus and equipped with features like the ! modality and recursion. The proposed denotational model is the first one that supports the full features of a quantum functional programming language; we prove adequacy of our semantics. The construction of our model is by a series of existing techniques taken from the semantics of classical computation as well as from process theory. The most notable among them is Girard's Geometry of Interaction (GoI), categorically formulated by Abramsky, Haghverdi and Scott. The mathematical genericity of these techniques—largely due to their categorical formulation—is exploited for our move from classical to quantum.},
  keywords = {higher-order computation, quantum computation, programming languages, geometry of interaction, denotational semantics, categorical semantics},
  note = {Eighth Games for Logic and Programming Languages Workshop (GaLoP)},
  webnote = {Eighth Games for Logic and Programming Languages Workshop (GaLoP)},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Heim2020"></a><pre>
@phdthesis{<a href="bbt.html#Heim2020">Heim2020</a>,
  title = {Development of Quantum Applications},
  author = {Heim, Bettina},
  year = {2020},
  month = dec,
  school = {ETH Zurich},
  address = {Zurich},
  numpages = {202},
  doi = {10.3929/ethz-b-000468201},
  abstract = {The aim of this thesis is to identify practical applications where quantum computing could have an advantage over what is achievable with conventional means of computing, and what advances are needed in order to actualize that potential. We investigate the possibilities on both quantum annealing devices (analogue quantum computers) as well as on gate-based devices (digital quantum computers). Quantum annealing devices in particular have grown in size and capabilities over the last decade. While they are natural candidates for providing improved solvers for NP-complete optimization problems, the number of qubits, accuracies and available couplings are still limited and their aptitude has yet to be confirmed. We use Monte Carlo methods and conceive an adaptive annealing schedule to assess the options to leverage them for the construction of satisfiability filters. We furthermore investigate their prospective as heuristic solvers for the traveling salesman problem, and what future enhancements in terms of geometries and couplings would be beneficial for that. Based on our simulations there is no reason to expect any benefits to leveraging analogue quantum computers over state-of-the-art classical methods. However, we see an implementation of annealing schemes on future digital devices as a promising approach that doesn't suffer from the same issues that impede performance on analogue devises. To that effect, we construct and implement an efficient quantization of the Metropolis-Hastings algorithm. Opposed to following the common way of quantization {\`a} la Szegedy that is usually defined with respect to an oracle, we reformulate the walk to closely mimic the classical algorithm and thus circumvent having to rely on costly quantum arithmetics. Our proposed realization thereby can lead to substantial savings. While theoretical arguments promise a quadratic speedup in the asymptotic limit, we numerically confirm that a polynomial speedup in terms of minimal total time to solution can be achieved for pragmatic use. We explore the prospects of using quantum walks in a heuristic setting and estimate the gate times the would be required to outperform a classical supercomputer. Finally, we elaborate on the role of programming languages, and how software tools can accelerate the advancement of the field. We discuss unique aspects of quantum programming and the purpose of Q\# in particular, and conclude by highlighting what developments are needed for quantum computing to live up to its potential.},
  keywords = {programming languages, quantum programming, quantum computing, q\#},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Heim2020a"></a><pre>
@article{<a href="bbt.html#Heim2020a">Heim2020a</a>,
  title = {Quantum Programming Languages},
  author = {Heim, Bettina and Soeken, Mathias and Marshall, Sarah and Granade, Christopher E. and Roetteler, Martin and Geller, Alan and Troyer, Matthias and Svore, Krysta M.},
  year = {2020},
  month = dec,
  journal = {Nature Reviews Physics},
  volume = {2},
  number = {12},
  pages = {709--722},
  doi = {10.1038/s42254-020-00245-7},
  url = {<a href="https://github.com/msr-quarc/quantum-languages-review">https://github.com/msr-quarc/quantum-languages-review</a>},
  abstract = {Quantum programming languages are essential to translate ideas into instructions that can be executed by a quantum computer. Not only are they crucial to the programming of quantum computers at scale but also they can facilitate the discovery and development of quantum algorithms even before hardware exists that is capable of executing them. Quantum programming languages are used for controlling existing physical devices, for estimating the execution costs of quantum algorithms on future devices, for teaching quantum computing concepts, or for verifying quantum algorithms and their implementations. They are used by newcomers and seasoned practitioners, researchers and developers working on the next ground-breaking discovery or applying known concepts to real-world problems. This variety in purpose and target audiences is reflected in the design and ecosystem of the existing quantum programming languages, depending on which factors a language prioritizes. In this Review, we highlight important aspects of quantum programming and how it differs from conventional programming. We overview a selection of several state-of-the-art quantum programming languages, highlight their salient features, and provide code samples for each of the languages and Docker files to facilitate installation of the software packages.},
  webnote = {Content overlap with Ch. 6--7 of \cite{Heim2020}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Heunen2019"></a><pre>
@book{<a href="bbt.html#Heunen2019">Heunen2019</a>,
  title = {Categories for Quantum Theory: An Introduction},
  author = {Heunen, Chris and Vicary, Jamie},
  year = {2019},
  month = nov,
  booktitle = {Categories for Quantum Theory: An Introduction},
  publisher = {{Oxford University Press}},
  address = {Oxford},
  doi = {10.1093/oso/9780198739623.001.0001},
  abstract = {Monoidal category theory serves as a powerful framework for describing logical aspects of quantum theory, giving an abstract language for parallel and sequential composition, and a conceptual way to understand many high-level quantum phenomena. This text lays the foundation for this categorical quantum mechanics, with an emphasis on the graphical calculus which makes computation intuitive. Biproducts and dual objects are introduced and used to model superposition and entanglement, with quantum teleportation studied abstractly using these structures. Monoids, Frobenius structures and Hopf algebras are described, and it is shown how they can be used to model classical information and complementary observables. The CP construction, a categorical tool to describe probabilistic quantum systems, is also investigated. The last chapter introduces higher categories, surface diagrams and 2-Hilbert spaces, and shows how the language of duality in monoidal 2-categories can be used to reason about quantum protocols, including quantum teleportation and dense coding.

               Prior knowledge of linear algebra, quantum information or category theory would give an ideal background for studying this text, but it is not assumed, with essential background material given in a self-contained introductory chapter. Throughout the text links with many other areas are highlighted, such as representation theory, topology, quantum algebra, knot theory, and probability theory, and nonstandard models are presented, such as sets and relations. All results are stated rigorously, and full proofs are given as far as possible, making this book an invaluable reference for modern techniques in quantum logic, with much of the material not available in any other textbook.},
  keywords = {category, category theory, quantum theory, graphical calculus, quantum teleportation, compositionality, higher categories, tensor product, hopf algebras, frobenius algebras},
  webnote = {Lecture notes (2013) that were source of this textbook are at http://www.cs.ox.ac.uk/people/jamie.vicary/IntroductionToCategoricalQuantumMechanics.pdf},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Heunen2022"></a><pre>
@article{<a href="bbt.html#Heunen2022">Heunen2022</a>,
  title = {Quantum Information Effects},
  author = {Heunen, Chris and Kaarsgaard, Robin},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  eid = {2},
  pages = {2},
  numpages = {27},
  doi = {10.1145/3498663},
  url = {<a href="https://github.com/rkaarsgaard/upi">https://github.com/rkaarsgaard/upi</a>},
  abstract = {We study the two dual quantum information effects to manipulate the amount of information in quantum computation: hiding and allocation. The resulting type-and-effect system is fully expressive for irreversible quantum computing, including measurement. We provide universal categorical constructions that semantically interpret this arrow metalanguage with choice, starting with any rig groupoid interpreting the reversible base language. Several properties of quantum measurement follow in general, and we translate quantum flow charts into our language. The semantic constructions turn the category of unitaries between Hilbert spaces into the category of completely positive trace-preserving maps, and they turn the category of bijections between finite sets into the category of functions with chosen garbage. Thus they capture the fundamental theorems of classical and quantum reversible computing of Toffoli and Stinespring.},
  keywords = {effects, quantum computation, reversible computation, information effects, measurement, categorical semantics, arrows},
  webnote = {POPL '22},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Hietala2021"></a><pre>
@article{<a href="bbt.html#Hietala2021">Hietala2021</a>,
  title = {A Verified Optimizer for {{Quantum}} Circuits},
  author = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Wu, Xiaodi and Hicks, Michael},
  year = {2021},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {5},
  number = {POPL},
  eid = {37},
  pages = {37},
  numpages = {29},
  doi = {10.1145/3434318},
  archiveprefix = {arXiv},
  eprint = {1912.02250},
  url = {<a href="https://github.com/inQWIRE/SQIR">https://github.com/inQWIRE/SQIR</a>},
  abstract = {We present VOQC, the first fully verified optimizer for quantum circuits, written using the Coq proof assistant. Quantum circuits are expressed as programs in a simple, low-level language called SQIR, a simple quantum intermediate representation, which is deeply embedded in Coq. Optimizations and other transformations are expressed as Coq functions, which are proved correct with respect to a semantics of SQIR programs. SQIR uses a semantics of matrices of complex numbers, which is the standard for quantum computation, but treats matrices symbolically in order to reason about programs that use an arbitrary number of quantum bits. SQIR's careful design and our provided automation make it possible to write and verify a broad range of optimizations in VOQC, including full-circuit transformations from cutting-edge optimizers.},
  keywords = {programming languages, formal verification, certified compilation, quantum computing, circuit optimization},
  webnote = {POPL '21. See arXiv version for full paper with appendix.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Hietala2021a"></a><pre>
@inproceedings{<a href="bbt.html#Hietala2021a">Hietala2021a</a>,
  title = {{Proving Quantum Programs Correct}},
  author = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Li, Liyi and Hicks, Michael},
  year = {2021},
  month = jun,
  booktitle = {12th International Conference on Interactive Theorem Proving (ITP 2021)},
  editor = {Cohen, Liron and Kaliszyk, Cezary},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {193},
  eid = {21},
  pages = {21:1--21:19},
  doi = {10.4230/LIPIcs.ITP.2021.21},
  url = {<a href="https://github.com/inQWIRE/SQIR">https://github.com/inQWIRE/SQIR</a>},
  abstract = {As quantum computing progresses steadily from theory into practice, programmers will face a common problem: How can they be sure that their code does what they intend it to do? This paper presents encouraging results in the application of mechanized proof to the domain of quantum programming in the context of the SQIR development. It verifies the correctness of a range of a quantum algorithms including Grover's algorithm and quantum phase estimation, a key component of Shor's algorithm. In doing so, it aims to highlight both the successes and challenges of formal verification in the quantum context and motivate the theorem proving community to target quantum computing as an application domain.},
  keywords = {formal verification, quantum computing, proof engineering},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Hietala2022"></a><pre>
@phdthesis{<a href="bbt.html#Hietala2022">Hietala2022</a>,
  title = {A Verified Software Toolchain For Quantum Programming},
  author = {Hietala, Kesha},
  year = {2022},
  month = jul,
  school = {University of Maryland},
  address = {College Park, MD, USA},
  doi = {10.13016/3el9-osue},
  abstract = {Quantum computing is steadily moving from theory into practice, with small-scale quantum computers available for public use. Now quantum programmers are faced with a classical problem: How can they be sure that their code does what they intend it to do? I aim to show that techniques for classical program verification can be adapted to the quantum setting, allowing for the development of high-assurance quantum software, without sacrificing performance or programmability. In support of this thesis, I present several results in the application of formal methods to the domain of quantum programming, aiming to provide a high-assurance software toolchain for quantum programming. I begin by presenting SQIR, a small quantum intermediate representation deeply embedded in the Coq proof assistant, which has been used to implement and prove correct quantum algorithms such as Grover's search and Shor's factorization algorithm. Next, I present VOQC, a verified optimizer for quantum circuits that contains state-of-the-art SQIR program optimizations with performance on par with unverified tools. I additionally discuss VQO, a framework for specifying and verifying oracle programs, which can then be optimized with VOQC. Finally, I present developing work on providing assurance for a high-level industry quantum programming language, Q\#, in the F* proof assistant.},
  keywords = {compilers, formal verification, programming languages, quantum computing},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Honda2015"></a><pre>
@inproceedings{<a href="bbt.html#Honda2015">Honda2015</a>,
  title = {Analysis of Quantum Entanglement in Quantum Programs using Stabilizer Formalism},
  author = {Honda, Kentaro},
  year = {2015},
  month = nov,
  booktitle = {Proceedings of the 12th International Workshop on Quantum Physics and Logic (QPL), Oxford, U.K., July 15--17, 2015},
  editor = {Heunen, Chris and Selinger, Peter and Vicary, Jamie},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {195},
  pages = {262--272},
  doi = {10.4204/EPTCS.195.19},
  abstract = {Quantum entanglement plays an important role in quantum computation and communication. It is necessary for many protocols and computations, but causes unexpected disturbance of computational states. Hence, static analysis of quantum entanglement in quantum programs is necessary. Several papers studied the problem. They decided qubits were entangled if multiple qubits unitary gates are applied to them, and some refined this reasoning using information about the state of each separated qubit. However, they do not care about the fact that unitary gate undoes entanglement and that measurement may separate multiple qubits. In this paper, we extend prior work using stabilizer formalism. It refines reasoning about separability of quantum variables in quantum programs.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Huang2019"></a><pre>
@inproceedings{<a href="bbt.html#Huang2019">Huang2019</a>,
  title = {{QDB: From Quantum Algorithms Towards Correct Quantum Programs}},
  author = {Huang, Yipeng and Martonosi, Margaret},
  year = {2019},
  month = jan,
  booktitle = {9th Workshop on Evaluation and Usability of Programming  Languages and Tools (PLATEAU 2018)},
  editor = {Titus Barik and Joshua Sunshine and Sarah Chasins},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {OpenAccess Series in Informatics (OASIcs)},
  volume = {67},
  eid = {4},
  pages = {4:1--4:14},
  doi = {10.4230/OASIcs.PLATEAU.2018.4},
  abstract = {With the advent of small-scale prototype quantum computers, researchers can now code and run quantum algorithms that were previously proposed but not fully implemented. In support of this growing interest in quantum computing experimentation, programmers need new tools and techniques to write and debug QC code. In this work, we implement a range of QC algorithms and programs in order to discover what types of bugs occur and what defenses against those bugs are possible in QC programs. We conduct our study by running small-sized QC programs in QC simulators in order to replicate published results in QC implementations. Where possible, we cross-validate results from programs written in different QC languages for the same problems and inputs. Drawing on this experience, we provide a taxonomy for QC bugs, and we propose QC language features that would aid in writing correct code.},
  keywords = {correctness, debugging},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Huot2019"></a><pre>
@inproceedings{<a href="bbt.html#Huot2019">Huot2019</a>,
  title = {Universal Properties in Quantum Theory},
  author = {Huot, Mathieu and Staton, Sam},
  year = {2019},
  month = jan,
  booktitle = {Proceedings of the 15th International Conference on Quantum Physics and Logic (QPL), Halifax, Canada, June 3--7, 2018},
  editor = {Selinger, Peter and Chiribella, Giulio},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {287},
  pages = {213--223},
  doi = {10.4204/EPTCS.287.12},
  abstract = {We argue that notions in quantum theory should have universal properties in the sense of category theory. We consider the completely positive trace preserving (CPTP) maps, the basic notion of quantum channel. Physically, quantum channels are derived from pure quantum theory by allowing discarding. We phrase this in category theoretic terms by showing that the category of CPTP maps is the universal monoidal category with a terminal unit that has a functor from the category of isometries. In other words, the CPTP maps are the affine reflection of the isometries.},
  keywords = {category theory, quantum theory, monoidal category},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Huot2019a"></a><pre>
@inproceedings{<a href="bbt.html#Huot2019a">Huot2019a</a>,
  title = {Quantum channels as a categorical completion},
  author = {Huot, Mathieu and Staton, Sam},
  year = {2019},
  month = jun,
  booktitle = {Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science},
  publisher = {{IEEE Computer Society}},
  address = {Los Alamitos, CA, USA},
  series = {{{LICS}} '19},
  eid = {35},
  pages = {35},
  numpages = {13},
  doi = {10.1109/LICS.2019.8785700},
  archiveprefix = {arXiv},
  eprint = {1904.09600},
  abstract = {We propose a categorical foundation for the connection between pure and mixed states in quantum information and quantum computation. The foundation is based on distributive monoidal categories. First, we prove that the category of all quantum channels is a canonical completion of the category of pure quantum operations (with ancilla preparations). More precisely, we prove that the category of completely positive trace-preserving maps between finite-dimensional C*-algebras is a canonical completion of the category of finite-dimensional vector spaces and isometries. Second, we extend our result to give a foundation to the topological relationships between quantum channels. We do this by generalizing our categorical foundation to the topologically-enriched setting. In particular, we show that the operator norm topology on quantum channels is the canonical topology induced by the norm topology on isometries.},
  keywords = {category theory, mathematical operators, quantum computing, quantum theory, topology, vectors},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ittah2022"></a><pre>
@article{<a href="bbt.html#Ittah2022">Ittah2022</a>,
  title = {QIRO: A Static Single Assignment-Based Quantum Program Representation for Optimization},
  author = {Ittah, David and H{\"a}ner, Thomas and Kliuchnikov, Vadym and Hoefler, Torsten},
  year = {2022},
  month = jul,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {3},
  number = {3},
  eid = {14},
  pages = {14},
  numpages = {32},
  doi = {10.1145/3491247},
  abstract = {We propose an IR for quantum computing that directly exposes quantum and classical data dependencies for the purpose of optimization. The Quantum Intermediate Representation for Optimization (QIRO) consists of two dialects, one input dialect and one that is specifically tailored to enable quantum-classical co-optimization. While the first employs a perhaps more intuitive memory-semantics (quantum operations act on qubits via side-effects), the latter uses value-semantics (operations consume and produce states) to integrate quantum dataflow in the IR's Static Single Assignment (SSA) graph. Crucially, this allows for a host of optimizations that leverage dataflow analysis. We discuss how to map existing quantum programming languages to the input dialect and how to lower the resulting IR to the optimization dialect. We present a prototype implementation based on MLIR that includes several quantum-specific optimization passes. Our benchmarks show that significant improvements in resource requirements are possible even through static optimization. In contrast to circuit optimization at run time, this is achieved while incurring only a small constant overhead in compilation time, making this a compelling approach for quantum program optimization at application scale.},
  keywords = {intermediate representation, dataflow optimization, quantum compilation, mlir},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="JavadiAbhari2012"></a><pre>
@techreport{<a href="bbt.html#JavadiAbhari2012">JavadiAbhari2012</a>,
  title = {Scaffold: {{Quantum}} Programming Language},
  author = {{Javadi-Abhari}, Ali and Faruque, Arvin and Dousti, Mohammad Javad and Svec, Lukas and Catu, Oana and Chakrabarti, Amlan and Chiang, Chen-Fu and Vanderwilt, Seth and Black, John and Chong, Frederic T. and Martonosi, Margaret and Suchara, Martin and Brown, Ken and Pedram, Massoud and Brun, Todd},
  year = {2012},
  month = jun,
  institution = {{Princeton University}},
  url = {<a href="https://www.cs.princeton.edu/research/techreps/TR-934-12">https://www.cs.princeton.edu/research/techreps/TR-934-12</a>},
  number = {TR-934-12},
  abstract = {Quantum computing is of significant research interest because of its potential to radically alter the performance and asymptotic complexity of certain computations. Over the years, physicists have explored possibilities for how to implement quantum bits and logic devices in hardware. At a higher level, mathematicians and algorithmicists have explored how to express computational problems from diverse fields---such as cryptography, chemical systems simulation, and database search---in terms of mathematical equations potentially implementable in quantum hardware.

                 For quantum computing to become potentially viable however, research must also make inroads regarding the implementation, compilation, and architectural issues that lie between high-level mathematical algorithm expressions and low-level physical implementations. In particular, we need tools and analysis techniques that can---for a given algorithm and potential physical implementation technology---answer questions like: how much would it cost (i.e., how much resource in terms of qubits, gates, time are required?) to implement the algorithm in this technology? What is its performance potential? Is it scalable? Are there more algorithms that offer such speedups over classical computers?

                 Our work is building a language and toolflow to answer such questions. This document describes the Scaffold programming language, its design goals, and related tools. Scaffold is a programming language for expressing quantum algorithms. A quantum algorithm can consist of a wide variety of components (including classical and quantum routines) which will be defined using different coding techniques. As a quantum programming language (QPL), Scaffold was formulated to make it easy to express an algorithm with so many disparate components in a clean and efficient manner. It is from this notion of ``putting things together'' that Scaffold derives its name.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="JavadiAbhari2015"></a><pre>
@article{<a href="bbt.html#JavadiAbhari2015">JavadiAbhari2015</a>,
  title = {{{ScaffCC}}: {{Scalable Compilation}} and {{Analysis}} of {{Quantum Programs}}},
  author = {{Javadi-Abhari}, Ali and Patil, Shruti and Kudrow, Daniel and Heckey, Jeff and Lvov, Alexey and Chong, Frederic T. and Martonosi, Margaret},
  year = {2015},
  month = jun,
  journal = {Parallel Computing},
  volume = {45},
  pages = {2--17},
  doi = {10.1016/j.parco.2014.12.001},
  archiveprefix = {arXiv},
  eprint = {1507.01902},
  abstract = {We present ScaffCC, a scalable compilation and analysis framework based on LLVM (Lattner and Adve, 2004), which can be used for compiling quantum computing applications at the logical level. Drawing upon mature compiler technologies, we discuss similarities and differences between compilation of classical and quantum programs, and adapt our methods to optimizing the compilation time and output for the quantum case. Our work also integrates a reversible-logic synthesis tool in the compiler to facilitate coding of quantum circuits. Lastly, we present some useful quantum program analysis scenarios and discuss their implications, specifically with an elaborate discussion of timing analysis for critical path estimation. Our work focuses on bridging the gap between high-level quantum algorithm specifications and low-level physical implementations, while providing good scalability to larger and more interesting problems.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Jia2022"></a><pre>
@article{<a href="bbt.html#Jia2022">Jia2022</a>,
  title = {Semantics for Variational Quantum Programming},
  author = {Jia, Xiaodong and Kornell, Andre and Lindenhovius, Bert and Mislove, Michael and Zamdzhiev, Vladimir},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  eid = {26},
  pages = {26},
  numpages = {31},
  doi = {10.1145/3498687},
  archiveprefix = {arXiv},
  eprint = {2107.13347},
  abstract = {We consider a programming language that can manipulate both classical and quantum information. Our language is type-safe and designed for variational quantum programming, which is a hybrid classical-quantum computational paradigm. The classical subsystem of the language is the Probabilistic FixPoint Calculus (PFPC), which is a lambda calculus with mixed-variance recursive types, term recursion and probabilistic choice. The quantum subsystem is a first-order linear type system that can manipulate quantum information. The two subsystems are related by mixed classical/quantum terms that specify how classical probabilistic effects are induced by quantum measurements, and conversely, how classical (probabilistic) programs can influence the quantum dynamics. We also describe a sound and computationally adequate denotational semantics for the language. Classical probabilistic effects are interpreted using a recently-described commutative probabilistic monad on DCPO. Quantum effects and resources are interpreted in a category of von Neumann algebras that we show is enriched over (continuous) domains. This strong sense of enrichment allows us to develop novel semantic methods that we use to interpret the relationship between the quantum and classical probabilistic effects. By doing so we provide a very detailed denotational analysis that relates domain-theoretic models of classical probabilistic programming to models of quantum programming.},
  keywords = {semantics, probabilistic programming, variational quantum programming},
  webnote = {POPL '22. See extended version on arXiv.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Jorrand2009"></a><pre>
@incollection{<a href="bbt.html#Jorrand2009">Jorrand2009</a>,
  title = {Abstract Interpretation Techniques for Quantum Computation},
  author = {Jorrand, Philippe and Perdrix, Simon},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  pages = {206--234},
  crossref = {<a href="#Gay2009">Gay2009</a>},
  doi = {10.1017/CBO9781139193313.007},
  abstract = {In this chapter, we present applications of abstract interpretation techniques in quantum computing. Quantum computing is a now well-established domain of computer science, and the recent developments of semantic techniques show the vitality of this rapidly growing area. On the other hand, the proof has been made that abstract interpretation is a powerful theory (of ``classical'' computer science) for comparing more or less precise semantics of the same programming language. In a more general picture, abstract interpretation can be seen as a framework for comparing the precision of several representations of the same dynamic system evolution. In this paper, we point out that abstract interpretation can be fruitfully used in quantum computing: (i) for establishing a hierarchy of quantum semantics and (ii) for analyzing entanglement evolution.},
  keywords = {abstract interpretation},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Knill1996"></a><pre>
@techreport{<a href="bbt.html#Knill1996">Knill1996</a>,
  title = {Conventions for Quantum Pseudocode},
  author = {Knill, Emanuel},
  year = {1996},
  month = jun,
  institution = {{Los Alamos National Laboratory}},
  number = {LA-UR-96-2724},
  doi = {10.2172/366453},
  abstract = {A few conventions for thinking about and writing quantum pseudocode are proposed. The conventions can be used for presenting any quantum algorithm down to the lowest level and are consistent with a quantum random access machine (QRAM) model for quantum computing. In principle a formal version of quantum pseudocode could be used in a future extension of a conventional language.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Kong2021"></a><pre>
@article{<a href="bbt.html#Kong2021">Kong2021</a>,
  title = {On the Impact of Affine Loop Transformations in Qubit Allocation},
  author = {Kong, Martin},
  year = {2021},
  month = sep,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {2},
  number = {3},
  eid = {9},
  pages = {9},
  numpages = {40},
  doi = {10.1145/3465409},
  abstract = {Most quantum compiler transformations and qubit allocation techniques to date are either peep-hole focused or rely on sliding windows that depend on a number of external parameters including the topology of the quantum processor. Thus, global optimization criteria are still lacking. In this article, we explore the synergies and impact of affine loop transformations in the context of qubit allocation and mapping. With this goal in mind, we designed and implemented AXL, a domain specific language and source-to-source compiler for quantum circuits that can be directly described with affine relations. We conduct an extensive evaluation spanning circuits from the recently introduced QUEKO benchmark suite, eight quantum circuits taken from the literature, three distinct coupling graphs, four affine transformations (including the Pluto dependence distance minimization and Feautrier's minimum latency algorithms), four qubit allocators, and two back-end quantum compilers. Our results demonstrate that affine transformations using global optimization criteria can cooperate effectively in several scenarios with quantum qubit mapping algorithms to reduce the circuit depth, size and allocation time.},
  keywords = {qubit allocation, polyhedral model, quantum computing, affine transformations},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Kornell2021"></a><pre>
@inproceedings{<a href="bbt.html#Kornell2021">Kornell2021</a>,
  title = {Quantum {CPOs}},
  author = {Kornell, Andre and Lindenhovius, Bert and Mislove, Michael},
  year = {2021},
  month = sep,
  booktitle = {Proceedings of the 17th International Conference on Quantum Physics and Logic (QPL), Paris, France, June 2--6, 2020},
  editor = {Valiron, Beno{\^i}t and Mansfield, Shane and Arrighi, Pablo and Panangaden, Prakash},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {340},
  pages = {174--187},
  doi = {10.4204/EPTCS.340.9},
  abstract = {We introduce the monoidal closed category qCPO of quantum cpos, whose objects are ``quantized'' analogs of omega-complete partial orders (cpos). The category qCPO is enriched over the category CPO of cpos, and contains both CPO, and the opposite of the category FdAlg of finite-dimensional von Neumann algebras as monoidal subcategories. We use qCPO to construct a sound model for the quantum programming language Proto-Quipper-M (PQM) extended with term recursion, as well as a sound and computationally adequate model for the Linear/Non-Linear Fixpoint Calculus (LNL-FPC), which is both an extension of the Fixpoint Calculus (FPC) with linear types, and an extension of a circuit-free fragment of PQM that includes recursive types.},
  keywords = {proto-quipper-m},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="LaRose2019"></a><pre>
@article{<a href="bbt.html#LaRose2019">LaRose2019</a>,
  title = {Overview and {{Comparison}} of {{Gate Level Quantum Software Platforms}}},
  author = {LaRose, Ryan},
  year = {2019},
  month = mar,
  journal = {Quantum},
  volume = {3},
  eid = {130},
  pages = {130},
  doi = {10.22331/q-2019-03-25-130},
  abstract = {Quantum computers are available to use over the cloud, but the recent explosion of quantum software platforms can be overwhelming for those deciding on which to use. In this paper, we provide a current picture of the rapidly evolving quantum computing landscape by comparing four software platforms - Forest (pyQuil), Qiskit, ProjectQ, and the Quantum Developer Kit (Q\#) - that enable researchers to use real and simulated quantum devices. Our analysis covers requirements and installation, language syntax through example programs, library support, and quantum simulator capabilities for each platform. For platforms that have quantum computer support, we compare hardware, quantum assembly languages, and quantum compilers. We conclude by covering features of each and briefly mentioning other quantum computing software packages.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="LaRose2022"></a><pre>
@article{<a href="bbt.html#LaRose2022">LaRose2022</a>,
  title = {Mitiq: {A} software package for error mitigation on noisy quantum computers},
  author = {LaRose, Ryan and Mari, Andrea and Kaiser, Sarah and Karalekas, Peter J. and Alves, Andre A. and Czarnik, Piotr and El Mandouh, Mohamed and Gordon, Max H. and Hindy, Yousef and Robertson, Aaron and Thakre, Purva and Wahl, Misty and Samuel, Danny and Mistri, Rahul and Tremblay, Maxime and Gardner, Nick and Stemen, Nathaniel T. and Shammah, Nathan and Zeng, William J.},
  year = {2022},
  month = aug,
  journal = {{Quantum}},
  volume = {6},
  eid = {774},
  pages = {774},
  doi = {10.22331/q-2022-08-11-774},
  url = {<a href="https://github.com/unitaryfund/mitiq">https://github.com/unitaryfund/mitiq</a>},
  abstract = {We introduce Mitiq, a Python package for error mitigation on noisy quantum computers. Error mitigation techniques can reduce the impact of noise on near-term quantum computers with minimal overhead in quantum resources by relying on a mixture of quantum sampling and classical post-processing techniques. Mitiq is an extensible toolkit of different error mitigation methods, including zero-noise extrapolation, probabilistic error cancellation, and Clifford data regression. The library is designed to be compatible with generic backends and interfaces with different quantum software frameworks. We describe Mitiq using code snippets to demonstrate usage and discuss features and contribution guidelines. We present several examples demonstrating error mitigation on IBM and Rigetti superconducting quantum processors as well as on noisy simulators.}
}
</pre>

<a name="Le2022"></a><pre>
@article{<a href="bbt.html#Le2022">Le2022</a>,
  author = {Le, Xuan-Bach and Lin, Shang-Wei and Sun, Jun and Sanan, David},
  title = {A Quantum Interpretation of Separating Conjunction for Local Reasoning of Quantum Programs Based on Separation Logic},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  eid = {36},
  pages = {36},
  numpages = {27},
  doi = {10.1145/3498697},
  abstract = {It is well-known that quantum programs are not only complicated to design but also challenging to verify because the quantum states can have exponential size and require sophisticated mathematics to encode and manipulate. To tackle the state-space explosion problem for quantum reasoning, we propose a Hoare-style inference framework that supports local reasoning for quantum programs. By providing a quantum interpretation of the separating conjunction, we are able to infuse separation logic into our framework and apply local reasoning using a quantum frame rule that is similar to the classical frame rule. For evaluation, we apply our framework to verify various quantum programs including Deutsch-Jozsa's algorithm and Grover's algorithm.},
  keywords = {verification, quantum computing, formal semantics, separation logic},
  webnote = {POPL '22},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Lee2021"></a><pre>
@inproceedings{<a href="bbt.html#Lee2021">Lee2021</a>,
  title = {{Concrete Categorical Model of a Quantum Circuit Description Language with Measurement}},
  author = {Lee, Dongho and Perrelle, Valentin and Valiron, Beno{\^i}t and Xu, Zhaowei},
  year = {2021},
  month = nov,
  booktitle = {41st IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2021)},
  editor = {Boja\'{n}czy, Mikołaj and Chekuri, Chandra},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {213},
  eid = {51},
  pages = {51:1--51:20},
  doi = {10.4230/LIPIcs.FSTTCS.2021.51},
  abstract = {In this paper, we introduce dynamic lifting to a quantum circuit-description language, following the Proto-Quipper language approach. Dynamic lifting allows programs to transfer the result of measuring quantum data -- qubits -- into classical data -- booleans -- . We propose a type system and an operational semantics for the language and we state safety properties. Next, we introduce a concrete categorical semantics for the proposed language, basing our approach on a recent model from Rios\&Selinger for Proto-Quipper-M. Our approach is to construct on top of a concrete category of circuits with measurements a Kleisli category, capturing as a side effect the action of retrieving classical content out of a quantum memory. We then show a soundness result for this semantics.},
  keywords = {categorical semantics, operational semantics, quantum circuit description language, proto-quipper-l, proto-quipper-m, dynamic lifting},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Lewis2021"></a><pre>
@misc{<a href="bbt.html#Lewis2021">Lewis2021</a>,
  title = {Formal Verification of Quantum Programs: Theory, Tools and Challenges},
  author = {Lewis, Marco and Soudjani, Sadegh and Zuliani, Paolo},
  year = {2021},
  month = oct,
  archiveprefix = {arXiv},
  eprint = {2110.01320},
  abstract = {Over the past 27 years, quantum computing has seen a huge rise in interest from both academia and industry. At the current rate, quantum computers are growing in size rapidly backed up by the increase of research in the field. Significant efforts are being made to improve the reliability of quantum hardware and to develop suitable software to program quantum computers. In contrast, the verification of quantum programs has received relatively less attention. The importance of verifying programs is especially important in the quantum setting due to how difficult it is to program complex algorithms correctly on resource-constrained and error-prone quantum hardware. Research into creating verification frameworks for quantum programs has seen recent development, with a variety of tools implemented using a collection of theoretical ideas. This survey aims to be a short introduction into the area of formal verification of quantum programs, bringing together theory and tools developed to date. Further, this survey examines some of the challenges that the field may face in the future, namely the developments of complex quantum algorithms.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Li2017"></a><pre>
@article{<a href="bbt.html#Li2017">Li2017</a>,
  title = {Algorithmic Analysis of Termination Problems for Quantum Programs},
  author = {Li, Yangjia and Ying, Mingsheng},
  year = {2017},
  month = dec,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {POPL},
  eid = {35},
  pages = {35},
  numpages = {29},
  doi = {10.1145/3158123},
  abstract = {We introduce the notion of linear ranking super-martingale (LRSM) for quantum programs (with nondeterministic choices, namely angelic and demonic choices). Several termination theorems are established showing that the existence of the LRSMs of a quantum program implies its termination. Thus, the termination problems of quantum programs is reduced to realisability and synthesis of LRSMs. We further show that the realisability and synthesis problem of LRSMs for quantum programs can be reduced to an SDP (Semi-Definite Programming) problem, which can be settled with the existing SDP solvers. The techniques developed in this paper are used to analyse the termination of several example quantum programs, including quantum random walks and quantum Bernoulli factory for random number generation. This work is essentially a generalisation of constraint-based approach to the corresponding problems for probabilistic programs developed in the recent literature by adding two novel ideas: (1) employing the fundamental Gleason's theorem in quantum mechanics to guide the choices of templates; and (2) a generalised Farkas' lemma in terms of observables (Hermitian operators) in quantum physics.},
  keywords = {sdp (semi-definite programming), quantum bernoulli factory, quantum programming, quantum random walk, ranking function, super-martingale, termination},
  webnote = {POPL '17},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Li2020"></a><pre>
@article{<a href="bbt.html#Li2020">Li2020</a>,
  title = {Projection-Based Runtime Assertions for Testing and Debugging Quantum Programs},
  author = {Li, Gushu and Zhou, Li and Yu, Nengkun and Ding, Yufei and Ying, Mingsheng and Xie, Yuan},
  year = {2020},
  month = nov,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {OOPSLA},
  eid = {150},
  pages = {150},
  numpages = {29},
  doi = {10.1145/3428218},
  abstract = {In this paper, we propose Proq, a runtime assertion scheme for testing and debugging quantum programs on a quantum computer. The predicates in Proq are represented by projections (or equivalently, closed subspaces of the state space), following Birkhoff-von Neumann quantum logic. The satisfaction of a projection by a quantum state can be directly checked upon a small number of projective measurements rather than a large number of repeated executions. On the theory side, we rigorously prove that checking projection-based assertions can help locate bugs or statistically assure that the semantic function of the tested program is close to what we expect, for both exact and approximate quantum programs. On the practice side, we consider hardware constraints and introduce several techniques to transform the assertions, making them directly executable on the measurement-restricted quantum computers. We also propose to achieve simplified assertion implementation using local projection technique with soundness guaranteed. We compare Proq with existing quantum program assertions and demonstrate the effectiveness and efficiency of Proq by its applications to assert two sophisticated quantum algorithms, the Harrow-Hassidim-Lloyd algorithm and Shor's algorithm.},
  keywords = {assertion, quantum computing, program testing, quantum programming},
  webnote = {OOPSLA '20},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Li2021"></a><pre>
@inproceedings{<a href="bbt.html#Li2021">Li2021</a>,
  title = {{Quantum Relational Hoare Logic with Expectations}},
  author = {Li, Yangjia and Unruh, Dominique},
  year = {2021},
  month = jul,
  booktitle = {48th International Colloquium on Automata, Languages, and Programming (ICALP 2021)},
  editor = {Bansal, Nikhil and Merelli, Emanuela and Worrell, James},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {198},
  eid = {136},
  pages = {136:1--136:20},
  doi = {10.4230/LIPIcs.ICALP.2021.136},
  abstract = {We present a variant of the quantum relational Hoare logic from (Unruh, POPL 2019) that allows us to use ``expectations'' in pre- and postconditions. That is, when reasoning about pairs of programs, our logic allows us to quantitatively reason about how much certain pre-/postconditions are satisfied that refer to the relationship between the programs inputs/outputs.},
  keywords = {quantum cryptography, hoare logic, formal verification},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Lindenhovius2018"></a><pre>
@inproceedings{<a href="bbt.html#Lindenhovius2018">Lindenhovius2018</a>,
  title = {Enriching a {{Linear}}/{{Non}}-Linear {{Lambda Calculus}}: {{A Programming Language}} for {{String Diagrams}}},
  shorttitle = {Enriching a {{Linear}}/{{Non}}-Linear {{Lambda Calculus}}},
  author = {Lindenhovius, Bert and Mislove, Michael and Zamdzhiev, Vladimir},
  year = {2018},
  month = jul,
  booktitle = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{LICS}} '18},
  pages = {659--668},
  doi = {10.1145/3209108.3209196},
  archiveprefix = {arXiv},
  eprint = {1804.09822},
  abstract = {Linear/non-linear (LNL) models, as described by Benton, soundly model a LNL term calculus and LNL logic closely related to intuitionistic linear logic. Every such model induces a canonical enrichment that we show soundly models a LNL lambda calculus for string diagrams, introduced by Rios and Selinger (with primary application in quantum computing). Our abstract treatment of this language leads to simpler concrete models compared to those presented so far. We also extend the language with general recursion and prove soundness. Finally, we present an adequacy result for the diagram-free fragment of the language which corresponds to a modified version of Benton and Wadler's adjoint calculus with recursion.},
  keywords = {categorical semantics, string diagrams, enriched category theory, programming languages, quantum computing, proto-quipper-m},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Liu2019"></a><pre>
@inproceedings{<a href="bbt.html#Liu2019">Liu2019</a>,
  title = {Formal {{Verification}} of {{Quantum Algorithms Using Quantum Hoare Logic}}},
  author = {Liu, Junyi and Zhan, Bohua and Wang, Shuling and Ying, Shenggang and Liu, Tao and Li, Yangjia and Ying, Mingsheng and Zhan, Naijun},
  year = {2019},
  month = jul,
  booktitle = {Computer Aided Verification (CAV '19)},
  editor = {Dillig, Isil and Tasiran, Serdar},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {11562},
  pages = {187--207},
  doi = {10.1007/978-3-030-25543-5_12},
  abstract = {We formalize the theory of quantum Hoare logic (QHL) [TOPLAS 33(6),19], an extension of Hoare logic for reasoning about quantum programs. In particular, we formalize the syntax and semantics of quantum programs in Isabelle/HOL, write down the rules of quantum Hoare logic, and verify the soundness and completeness of the deduction system for partial correctness of quantum programs. As preliminary work, we formalize some necessary mathematical background in linear algebra, and define tensor products of vectors and matrices on quantum variables. As an application, we verify the correctness of Grover's search algorithm. To our best knowledge, this is the first time a Hoare logic for quantum programs is formalized in an interactive theorem prover, and used to verify the correctness of a nontrivial quantum algorithm.},
  keywords = {hoare logic},
  webnote = {See also: Isabelle AFP entry \cite{Liu2019a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Liu2019a"></a><pre>
@article{<a href="bbt.html#Liu2019a">Liu2019a</a>,
  title = {Quantum Hoare Logic},
  author = {Liu, Junyi and Zhan, Bohua and Wang, Shuling and Ying, Shenggang and Liu, Tao and Li, Yangjia and Ying, Mingsheng and Zhan, Naijun},
  year = {2019},
  month = mar,
  journal = {Archive of Formal Proofs},
  volume = {2019},
  url = {<a href="https://isa-afp.org/entries/QHLProver.html">https://isa-afp.org/entries/QHLProver.html</a>},
  abstract = {We formalize quantum Hoare logic [TOPLAS 33(6),19]. In particular, we specify the syntax and denotational semantics of a simple model of quantum programs. Then, we write down the rules of quantum Hoare logic for partial correctness, and show the soundness and completeness of the resulting proof system. As an application, we verify the correctness of Grover's algorithm.},
  keywords = {hoare logic},
  webnote = {Formal proof development in Isabelle, supplement to \cite{Liu2019}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Mahmoud2019"></a><pre>
@article{<a href="bbt.html#Mahmoud2019">Mahmoud2019</a>,
  title = {Formalization of {{Metatheory}} of the {{Quipper Quantum Programming Language}} in a {{Linear Logic}}},
  author = {Mahmoud, Mohamed Yousri and Felty, Amy P.},
  year = {2019},
  month = jun,
  journal = {Journal of Automated Reasoning},
  volume = {63},
  number = {4},
  pages = {967--1002},
  doi = {10.1007/s10817-019-09527-x},
  archiveprefix = {arXiv},
  eprint = {1812.03624},
  abstract = {We develop a linear logical framework within the Hybrid system and use it to reason about the type system of a quantum lambda calculus. In particular, we consider a practical version of the calculus called Proto-Quipper, which contains the core of Quipper. Quipper is a quantum programming language under active development and recently has gained much popularity among the quantum computing communities. Hybrid is a system that is designed to support the use of higher-order abstract syntax for representing and reasoning about formal systems implemented in the Coq Proof Assistant. In this work, we extend the system with a linear specification logic (SL) in order to reason about the linear type system of Quipper. To this end, we formalize the semantics of Proto-Quipper by encoding the typing and evaluation rules in the SL, and prove type soundness.},
  keywords = {proto-quipper, quantum programming languages, linear logic, hybrid, higher-order abstract syntax, coq},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="McCaskey2021"></a><pre>
@article{<a href="bbt.html#McCaskey2021">McCaskey2021</a>,
  title = {Extending C++ for Heterogeneous Quantum-Classical Computing},
  author = {McCaskey, Alexander and Nguyen, Thien and Santana, Anthony and Claudino, Daniel and Kharazi, Tyler and Finkel, Hal},
  year = {2021},
  month = jun,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {2},
  number = {2},
  eid = {6},
  pages = {6},
  numpages = {36},
  doi = {10.1145/3462670},
  archiveprefix = {arXiv},
  eprint = {2010.03935},
  abstract = {We present qcor—a language extension to C++ and compiler implementation that enables heterogeneous quantum-classical programming, compilation, and execution in a single-source context. Our work provides a first-of-its-kind C++ compiler enabling high-level quantum kernel (function) expression in a quantum-language agnostic manner, as well as a hardware-agnostic, retargetable compiler workflow targeting a number of physical and virtual quantum computing backends. qcor leverages novel Clang plugin interfaces and builds upon the XACC system-level quantum programming framework to provide a state-of-the-art integration mechanism for quantum-classical compilation that leverages the best from the community at-large. qcor translates quantum kernels ultimately to the XACC intermediate representation, and provides user-extensible hooks for quantum compilation routines like circuit optimization, analysis, and placement. This work details the overall architecture and compiler workflow for qcor, and provides a number of illuminating programming examples demonstrating its utility for near-term variational tasks, quantum algorithm expression, and feed-forward error correction schemes.},
  keywords = {domain specific languages, quantum programming, quantum computing, compilers},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Meuli2020"></a><pre>
@article{<a href="bbt.html#Meuli2020">Meuli2020</a>,
  title = {Enabling Accuracy-Aware Quantum Compilers Using Symbolic Resource Estimation},
  author = {Meuli, Giulia and Soeken, Mathias and Roetteler, Martin and H{\"a}ner, Thomas},
  year = {2020},
  month = nov,
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {4},
  number = {OOPSLA},
  eid = {130},
  pages = {130},
  doi = {10.1145/3428198},
  abstract = {Approximation errors must be taken into account when compiling quantum programs into a low-level gate set. We present a methodology that tracks such errors automatically and then optimizes accuracy parameters to guarantee a specified overall accuracy while aiming to minimize the implementation cost in terms of quantum gates. The core idea of our approach is to extract functions that specify the optimization problem directly from the high-level description of the quantum program. Then, custom compiler passes optimize these functions, turning them into (near-)symbolic expressions for (1) the total error and (2) the implementation cost (e.g., total quantum gate count). All unspecified parameters of the quantum program will show up as variables in these expressions, including accuracy parameters. After solving the corresponding optimization problem, a circuit can be instantiated from the found solution. We develop two prototype implementations, one in C++ based on Clang/LLVM, and another using the Q\# compiler infrastructure. We benchmark our prototypes on typical quantum computing programs, including the quantum Fourier transform, quantum phase estimation, and Shor's algorithm.},
  keywords = {quantum algorithms, approximation errors, resource estimation, quantum programming, quantum computing},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Mosca2019"></a><pre>
@article{<a href="bbt.html#Mosca2019">Mosca2019</a>,
  title = {{Quantum Programming Languages (Dagstuhl Seminar 18381)}},
  author = {Mosca, Michele and Roetteler, Martin and Selinger, Peter},
  year = {2019},
  month = mar,
  journal = {Dagstuhl Reports},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  volume = {8},
  number = {9},
  pages = {112--132},
  doi = {10.4230/DagRep.8.9.112},
  url = {<a href="https://www.dagstuhl.de/18381">https://www.dagstuhl.de/18381</a>},
  abstract = {This report documents the program and the outcomes of Dagstuhl Seminar 18381 ``Quantum Programming Languages'', which brought together researchers from quantum computing and classical programming languages.},
  keywords = {compilers, functional programming, quantum computing, reversible computing, verification},
  webnote = {Dagstuhl Reports, Volume 8, Issue 9. Seminar dates: September 16--21, 2018},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Nielsen2010"></a><pre>
@book{<a href="bbt.html#Nielsen2010">Nielsen2010</a>,
  title = {Quantum Computation and Quantum Information: 10th Anniversary Edition},
  author = {Nielsen, Michael A. and Chuang, Isaac L.},
  year = {2010},
  month = dec,
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  doi = {10.1017/CBO9780511976667},
  abstract = {One of the most cited books in physics of all time, Quantum Computation and Quantum Information remains the best textbook in this exciting field of science. This 10th anniversary edition includes an introduction from the authors setting the work in context. This comprehensive textbook describes such remarkable effects as fast quantum algorithms, quantum teleportation, quantum cryptography and quantum error-correction. Quantum mechanics and computer science are introduced before moving on to describe what a quantum computer is, how it can be used to solve problems faster than 'classical' computers and its real-world implementation. It concludes with an in-depth treatment of quantum information. Containing a wealth of figures and exercises, this well-known textbook is ideal for courses on the subject, and will interest beginning graduate students and researchers in physics, computer science, mathematics, and electrical engineering.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Oemer2003"></a><pre>
@phdthesis{<a href="bbt.html#Oemer2003">Oemer2003</a>,
  title = {Structured {{Quantum Programming}}},
  author = {{\"O}mer, Bernhard},
  year = {2003},
  month = may,
  school = {Vienna University of Technology},
  url = {<a href="http://www.itp.tuwien.ac.at/~oemer/doc/structquprog.pdf">http://www.itp.tuwien.ac.at/~oemer/doc/structquprog.pdf</a>},
  webnote = {Describes QCL},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Pagani2014"></a><pre>
@inproceedings{<a href="bbt.html#Pagani2014">Pagani2014</a>,
  title = {Applying Quantitative Semantics to Higher-Order Quantum Computing},
  author = {Pagani, Michele and Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2014},
  month = jan,
  booktitle = {Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {POPL '14},
  pages = {647--658},
  doi = {10.1145/2535838.2535879},
  archiveprefix = {arXiv},
  eprint = {1311.2290},
  abstract = {Finding a denotational semantics for higher order quantum computation is a long-standing problem in the semantics of quantum programming languages. Most past approaches to this problem fell short in one way or another, either limiting the language to an unusably small finitary fragment, or giving up important features of quantum physics such as entanglement. In this paper, we propose a denotational semantics for a quantum lambda calculus with recursion and an infinite data type, using constructions from quantitative semantics of linear logic.},
  keywords = {higher-order, quantum computation, completely positive maps, categorical model, functional programming},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paolini2017"></a><pre>
@inproceedings{<a href="bbt.html#Paolini2017">Paolini2017</a>,
  title = {{{qPCF}}: {{A Language}} for {{Quantum Circuit Computations}}},
  shorttitle = {qPCF},
  author = {Paolini, Luca and Zorzi, Margherita},
  year = {2017},
  month = apr,
  booktitle = {Theory and Applications of Models of Computation (TAMC '17)},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {10185},
  pages = {455--469},
  doi = {10.1007/978-3-319-55911-7_33},
  abstract = {We propose qPCF, a functional language able to define and manipulate quantum circuits in an easy and intuitive way. qPCF follows the tradition of ``quantum data & classical control'' languages, inspired to the QRAM model. Ideally, qPCF computes finite circuit descriptions which are offloaded to a quantum co-processor (i.e. a quantum device) for the execution. qPCF extends   PCF  with a new kind of datatype: quantum circuits. The typing of qPCF is quite different from the mainstream of ``quantum data & classical control'' languages that involves linear/exponential modalities. qPCF uses a simple form of dependent types to manage circuits and an implicit form of monad to manage quantum states via a destructive-measurement operator.},
  keywords = {quantum circuits, classical control, quantum programming languages},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paolini2019"></a><pre>
@inproceedings{<a href="bbt.html#Paolini2019">Paolini2019</a>,
  title = {Quantum {{Programming Made Easy}}},
  author = {Paolini, Luca and Roversi, Luca and Zorzi, Margherita},
  year = {2019},
  month = apr,
  booktitle = {Proceedings Joint International Workshop on Linearity \& Trends in Linear Logic and Applications (Linearity-TLLA '18), Oxford, UK, 7--8 July 2018},
  editor = {Ehrhard, Thomas and Fern{\'a}ndez, Maribel and de Paiva, Valeria and {Tortora de Falco}, Lorenzo},
  publisher = {{Open Publishing Association}},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {292},
  pages = {133--147},
  doi = {10.4204/EPTCS.292.8},
  abstract = {We present IQu, namely a quantum programming language that extends Reynold's Idealized Algol, the paradigmatic core of Algol-like languages. IQu combines imperative programming with high-order features, mediated by a simple type theory. IQu mildly merges its quantum features with the classical programming style that we can experiment through Idealized Algol, the aim being to ease a transition towards the quantum programming world. The proposed extension is done along two main directions. First, IQu makes the access to quantum co-processors by means of quantum stores. Second, IQu includes some support for the direct manipulation of quantum circuits, in accordance with recent trends in the development of quantum programming languages. Finally, we show that IQu is quite effective in expressing well-known quantum algorithms.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paolini2019a"></a><pre>
@article{<a href="bbt.html#Paolini2019a">Paolini2019a</a>,
  title = {{{QPCF}}: {{Higher}}-{{Order Languages}} and {{Quantum Circuits}}},
  shorttitle = {{{QPCF}}},
  author = {Paolini, Luca and Piccolo, Mauro and Zorzi, Margherita},
  year = {2019},
  month = mar,
  journal = {Journal of Automated Reasoning},
  volume = {63},
  number = {4},
  pages = {941--966},
  doi = {10.1007/s10817-019-09518-y},
  archiveprefix = {arXiv},
  eprint = {1809.05723},
  abstract = {qPCF is a paradigmatic quantum programming language that extends PCF with quantum circuits and a quantum co-processor. Quantum circuits are treated as classical data that can be duplicated and manipulated in flexible ways by means of a dependent type system. The co-processor is essentially a standard QRAM device, albeit we avoid to store permanently quantum states in between two co-processor's calls. Despite its quantum features, qPCF retains the classic programming approach of PCF. We introduce qPCF syntax, typing rules, and its operational semantics. We prove fundamental syntactic properties of the system. Moreover, we provide some higher-order examples of circuit encoding.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paradis2021"></a><pre>
@inproceedings{<a href="bbt.html#Paradis2021">Paradis2021</a>,
  title = {Unqomp: Synthesizing Uncomputation in Quantum Circuits},
  author = {Paradis, Anouk and Bichsel, Benjamin and Steffen, Samuel and Vechev, Martin},
  year = {2021},
  month = jun,
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{{PLDI}} '21},
  pages = {222--236},
  numpages = {15},
  doi = {10.1145/3453483.3454040},
  abstract = {A key challenge when writing quantum programs is the need for uncomputation: temporary values produced during the computation must be reset to zero before they can be safely discarded. Unfortunately, most existing quantum languages require tedious manual uncomputation, often leading to inefficient and error-prone programs. We present Unqomp, the first procedure to automatically synthesize uncomputation in a given quantum circuit. Unqomp can be readily integrated into popular quantum languages, allowing the programmer to allocate and use temporary values analogously to classical computation, knowing they will be uncomputed by Unqomp. Our evaluation shows that programs leveraging Unqomp are not only shorter (-19\% on average), but also generate more efficient circuits (-71\% gates and -19\% qubits on average).},
  keywords = {quantum Circuits, uncomputation, synthesis},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paykin2017"></a><pre>
@inproceedings{<a href="bbt.html#Paykin2017">Paykin2017</a>,
  title = {{{QWIRE}}: A Core Language for Quantum Circuits},
  author = {Paykin, Jennifer and Rand, Robert and Zdancewic, Steve},
  year = {2017},
  month = jan,
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{POPL}} '17},
  pages = {846--858},
  doi = {10.1145/3009837.3009894},
  url = {<a href="https://jpaykin.github.io/papers/prz_qwire_2017.pdf">https://jpaykin.github.io/papers/prz_qwire_2017.pdf</a>},
  abstract = {This paper introduces QWIRE (``choir''), a language for defining quantum circuits and an interface for manipulating them inside of an arbitrary classical host language. QWIRE is minimal---it contains only a few primitives---and sound with respect to the physical properties entailed by quantum mechanics. At the same time, QWIRE is expressive and highly modular due to its relationship with the host language, mirroring the QRAM model of computation that places a quantum computer (controlled by circuits) alongside a classical computer (controlled by the host language).

               We present QWIRE along with its type system and operational semantics, which we prove is safe and strongly normalizing whenever the host language is. We give circuits a denotational semantics in terms of density matrices. Throughout, we investigate examples that demonstrate the expressive power of QWIRE, including extensions to the host language that (1) expose a general analysis framework for circuits, and (2) provide dependent types.},
  keywords = {linear types, denotational semantics, quantum circuits, quantum programming languages},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paykin2018"></a><pre>
@phdthesis{<a href="bbt.html#Paykin2018">Paykin2018</a>,
  title = {{Linear/Non-Linear Types for Embedded Domain-Specific Languages}},
  author = {Paykin, Jennifer},
  year = {2018},
  month = aug,
  school = {University of Pennsylvania},
  address = {{Philadelphia, PA, USA}},
  url = {<a href="https://repository.upenn.edu/edissertations/2752/">https://repository.upenn.edu/edissertations/2752/</a>},
  abstract = {Domain-specific languages are often embedded inside of general-purpose host languages so that the embedded language can take advantage of host-language data structures, libraries, and tools. However, when the domain-specific language uses linear types, existing techniques for embedded languages fall short. Linear type systems, which have applications in a wide variety of programming domains including mutable state, I/O, concurrency, and quantum computing, can manipulate embedded non-linear data via the linear type !σ. However, prior work has not been able to produce linear embedded languages that have full and easy access to host-language data, libraries, and tools.

               This dissertation proposes a new perspective on linear, embedded, domain-specific languages derived from the linear/non-linear (LNL) interpretation of linear logic. The LNL model consists of two distinct fragments---one with linear types and another with non-linear types---and provides a simple categorical interface between the two. This dissertation identifies the linear fragment with the linear embedded language and the non-linear fragment with the general-purpose host language.

               The effectiveness of this framework is illustrated via a number of examples, implemented in a variety of host languages. In Haskell, linear domain-specific languages using mutable state and concurrency can take advantage of the monad that arises from the LNL model. In Coq, the QWIRE quantum circuit language uses linearity to enforce the no-cloning axiom of quantum mechanics. In homotopy type theory, quantum transformations can be encoded as higher inductive types to simplify the presentation of a quantum equational theory. These examples serve as case studies that prove linear/non-linear type theory is a natural and expressive interface in which to embed linear domain-specific languages.},
  note = {Publicly Accessible Penn Dissertations. 2752},
  webnote = {Publicly Accessible Penn Dissertations. 2752.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Paykin2019"></a><pre>
@misc{<a href="bbt.html#Paykin2019">Paykin2019</a>,
  title = {A {{HoTT Quantum Equational Theory}} ({{Extended Version}})},
  author = {Paykin, Jennifer and Zdancewic, Steve},
  year = {2019},
  month = apr,
  archiveprefix = {arXiv},
  eprint = {1904.04371},
  abstract = {This paper presents an equational theory for the QRAM model of quantum computation, formulated as an embedded language inside of homotopy type theory. The embedded language approach is highly expressive, and reflects the style of state-of-the art quantum languages like Quipper and QWIRE. The embedding takes advantage of features of homotopy type theory to encode unitary transformations as higher inductive paths, simplifying the presentation of an equational theory. We prove that this equational theory is sound and complete with respect to established models of quantum computation.},
  note = {QPL '19},
  webnote = {QPL '19},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Pechoux2020"></a><pre>
@inproceedings{<a href="bbt.html#Pechoux2020">Pechoux2020</a>,
  title = {Quantum Programming with Inductive Datatypes: Causality and Affine Type Theory},
  author = {P{\'e}choux, Romain and Perdrix, Simon and Rennela, Mathys and Zamdzhiev, Vladimir},
  year = {2020},
  month = apr,
  booktitle = {Foundations of Software Science and Computation Structures, FoSSaCS 2020},
  editor = {Goubault-Larrecq, Jean and K{\"o}nig, Barbara},
  publisher = {{Springer International Publishing}},
  address = {Cham},
  series = {Lecture Notes in Computer Science},
  volume = {12077},
  pages = {562--581},
  doi = {10.1007/978-3-030-45231-5_29},
  abstract = {Inductive datatypes in programming languages allow users to define useful data structures such as natural numbers, lists, trees, and others. In this paper we show how inductive datatypes may be added to the quantum programming language QPL. We construct a sound categorical model for the language and by doing so we provide the first detailed semantic treatment of user-defined inductive datatypes in quantum programming. We also show our denotational interpretation is invariant with respect to big-step reduction, thereby establishing another novel result for quantum programming. Compared to classical programming, this property is considerably more difficult to prove and we demonstrate its usefulness by showing how it immediately implies computational adequacy at all types. To further cement our results, our semantics is entirely based on a physically natural model of von Neumann algebras, which are mathematical structures used by physicists to study quantum mechanics.},
  keywords = {quantum programming, inductive types, adequacy},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Peng2022"></a><pre>
@inproceedings{<a href="bbt.html#Peng2022">Peng2022</a>,
  title = {Algebraic Reasoning of Quantum Programs via Non-Idempotent Kleene Algebra},
  author = {Peng, Yuxiang and Ying, Mingsheng and Wu, Xiaodi},
  year = {2022},
  month = jun,
  booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{{PLDI}} '22},
  pages = {657--670},
  numpages = {14},
  doi = {10.1145/3519939.3523713},
  archiveprefix = {arXiv},
  eprint = {2110.07018},
  abstract = {We investigate the algebraic reasoning of quantum programs inspired by the success of classical program analysis based on Kleene algebra. One prominent example of such is the famous Kleene Algebra with Tests (KAT), which has furnished both theoretical insights and practical tools. The succinctness of algebraic reasoning would be especially desirable for scalable analysis of quantum programs, given the involvement of exponential-size matrices in most of the existing methods. A few key features of KAT including the idempotent law and the nice properties of classical tests, however, fail to hold in the context of quantum programs due to their unique quantum features, especially in branching. We propose the Non-idempotent Kleena Algebra (NKA) as a natural alternative, and identify complete and sound semantic models for NKA as well as their quantum interpretations. In light of applications of KAT, we demonstrate algebraic proofs in NKA of quantum compiler optimization and the normal form of quantum \textbf{while}-programs. Moreover, we extend NKA with Tests (i.e., NKAT), where tests model quantum predicates following effect algebra, and illustrate how to encode propositional quantum Hoare logic as NKAT theorems.},
  keywords = {non-idempotent kleene algebra, compiler optimization, normal form theorem, quantum hoare logic},
  webnote = {See arXiv for extended version.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Peng2022a"></a><pre>
@misc{<a href="bbt.html#Peng2022a">Peng2022a</a>,
  title = {A Formally Certified End-to-End Implementation of Shor's Factorization Algorithm},
  author = {Peng, Yuxiang and Hietala, Kesha and Tao, Runzhou and Li, Liyi and Rand, Robert and Hicks, Michael and Wu, Xiaodi},
  year = {2022},
  month = apr,
  archiveprefix = {arXiv},
  eprint = {2204.07112},
  url = {<a href="https://github.com/inQWIRE/SQIR/tree/main/examples/shor">https://github.com/inQWIRE/SQIR/tree/main/examples/shor</a>},
  abstract = {Quantum computing technology may soon deliver revolutionary improvements in algorithmic performance, but these are only useful if computed answers are correct. While hardware-level decoherence errors have garnered significant attention, a less recognized obstacle to correctness is that of human programming errors -- ``bugs''. Techniques familiar to most programmers from the classical domain for avoiding, discovering, and diagnosing bugs do not easily transfer, at scale, to the quantum domain because of its unique characteristics. To address this problem, we have been working to adapt formal methods to quantum programming. With such methods, a programmer writes a mathematical specification alongside their program, and semi-automatically proves the program correct with respect to it. The proof's validity is automatically confirmed -- certified -- by a ``proof assistant''. Formal methods have successfully yielded high-assurance classical software artifacts, and the underlying technology has produced certified proofs of major mathematical theorems. As a demonstration of the feasibility of applying formal methods to quantum programming, we present the first formally certified end-to-end implementation of Shor's prime factorization algorithm, developed as part of a novel framework for applying the certified approach to general applications. By leveraging our framework, one can significantly reduce the effects of human errors and obtain a high-assurance implementation of large-scale quantum applications in a principled way.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="QIRSpec2021"></a><pre>
@manual{<a href="bbt.html#QIRSpec2021">QIRSpec2021</a>,
  title = {{QIR Specification}},
  author = {{QIR Alliance}},
  year = {2021},
  month = nov,
  url = {<a href="https://github.com/qir-alliance/qir-spec">https://github.com/qir-alliance/qir-spec</a>},
  abstract = {The QIR specification is an effort of the QIR Alliance. It defines how to represent quantum programs within the LLVM IR.},
  note = {Also see \url{https://qir-alliance.org}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="QiskitCommunity2017"></a><pre>
@misc{<a href="bbt.html#QiskitCommunity2017">QiskitCommunity2017</a>,
  title = {Qiskit: {{An}} Open-Source Framework for Quantum Computing},
  author = {{Qiskit Community}},
  year = {2017},
  month = mar,
  doi = {10.5281/zenodo.2562110},
  url = {<a href="https://github.com/Qiskit/qiskit">https://github.com/Qiskit/qiskit</a>},
  abstract = {Qiskit is an open-source framework for working with noisy quantum computers at the level of pulses, circuits, and algorithms. https://qiskit.org},
  webnote = {The official way to cite Qiskit is using the bibentry at \url{https://github.com/Qiskit/qiskit/blob/master/Qiskit.bib}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="QsSpec2020"></a><pre>
@manual{<a href="bbt.html#QsSpec2020">QsSpec2020</a>,
  title = {Q\# {Language Specification}},
  author = {Microsoft},
  year = {2020},
  month = sep,
  url = {<a href="https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language#q-language">https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language#q-language</a>},
  abstract = {Q\# is part of Microsoft's Quantum Development Kit and provides rich IDE support and tools for program visualization and analysis. Our goal is to support the development of future large-scale applications while supporting user's first efforts in that direction on current quantum hardware.

               The type system permits Q\# programs to safely interleave and naturally represent the composition of classical and quantum computations. A Q\# program may express arbitrary classical computations based on quantum measurements that execute while qubits remain live, meaning they are not released and maintain their state. Even though the full complexity of such computations requires further hardware development, Q\# programs can be targeted to run on various quantum hardware backends in Azure Quantum.

               Q\# is a stand-alone language offering a high level of abstraction. There is no notion of a quantum state or a circuit; instead, Q\# implements programs in terms of statements and expressions, much like classical programming languages. Distinct quantum capabilities (such as support for functors and control-flow constructs) facilitate expressing, for example, phase estimation and quantum chemistry algorithms.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="QuingoTeam2021"></a><pre>
@article{<a href="bbt.html#QuingoTeam2021">QuingoTeam2021</a>,
  title = {Quingo: A Programming Framework for Heterogeneous Quantum-Classical Computing with NISQ Features},
  author = {{Quingo Development Team}},
  year = {2021},
  month = dec,
  journal = {ACM Transactions on Quantum Computing},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  volume = {2},
  number = {4},
  eid = {19},
  pages = {19},
  numpages = {37},
  doi = {10.1145/3483528},
  url = {<a href="https://github.com/Quingo">https://github.com/Quingo</a>},
  abstract = {The increasing control complexity of Noisy Intermediate-Scale Quantum (NISQ) systems underlines the necessity of integrating quantum hardware with quantum software. While mapping heterogeneous quantum-classical computing (HQCC) algorithms to NISQ hardware for execution, we observed a few dissatisfactions in quantum programming languages (QPLs), including difficult mapping to hardware, limited expressiveness, and counter-intuitive code. In addition, noisy qubits require repeatedly performed quantum experiments, which explicitly operate low-level configurations, such as pulses and timing of operations. This requirement is beyond the scope or capability of most existing QPLs.We summarize three execution models to depict the quantum-classical interaction of existing QPLs. Based on the refined HQCC model, we propose the Quingo framework to integrate and manage quantum-classical software and hardware to provide the programmability over HQCC applications and map them to NISQ hardware. We propose a six-phase quantum program life-cycle model matching the refined HQCC model, which is implemented by a runtime system. We also propose the Quingo programming language, an external domain-specific language highlighting timer-based timing control and opaque operation definition, which can be used to describe quantum experiments. We believe the Quingo framework could contribute to the clarification of key techniques in the design of future HQCC systems.},
  keywords = {nisq, quantum compilation, timing control, quantum programming framework, quantum programming language},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2016"></a><pre>
@misc{<a href="bbt.html#Rand2016">Rand2016</a>,
  title = {Verification {{Logics}} for {{Quantum Programs}}},
  author = {Rand, Robert},
  year = {2016},
  month = mar,
  institution = {University of Pennsylvania},
  pages = {42},
  archiveprefix = {arXiv},
  eprint = {1904.04304},
  abstract = {We survey the landscape of Hoare logics for quantum programs. We review three papers: ``Reasoning about imperative quantum programs'' by Chadha, Mateus and Sernadas; ``A logic for formal verification of quantum programs'' by Yoshihiko Kakutani; and ``Floyd-hoare logic for quantum programs'' by Mingsheng Ying. We compare the mathematical foundations of the logics, their underlying languages, and the expressivity of their assertions. We also use the languages to verify the Deutsch--Jozsa Algorithm, and discuss their relative usability in practice.},
  keywords = {hoare logic},
  note = {Submitted as a qualifying examination (WPE-II) for the PhD program at the University of Pennsylvania},
  webnote = {Submitted as a qualifying examination (WPE-II) for the PhD program at the University of Pennsylvania.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2018"></a><pre>
@inproceedings{<a href="bbt.html#Rand2018">Rand2018</a>,
  title = {{{QWIRE}} Practice: {{Formal}} Verification of Quantum Circuits in Coq},
  author = {Rand, Robert and Paykin, Jennifer and Zdancewic, Steve},
  year = {2018},
  month = feb,
  booktitle = {Proceedings of the 14th International Conference on Quantum Physics and Logic (QPL), Nijmegen, the Netherlands, July 3--7, 2017},
  editor = {Coecke, Bob and Kissinger, Aleks},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {266},
  pages = {119--132},
  doi = {10.4204/EPTCS.266.8},
  abstract = {We describe an embedding of the QWIRE quantum circuit language in the Coq proof assistant. This allows programmers to write quantum circuits using high-level abstractions and to prove properties of those circuits using Coq's theorem proving features. The implementation uses higher-order abstract syntax to represent variable binding and provides a type-checking algorithm for linear wire types, ensuring that quantum circuits are well-formed. We formalize a denotational semantics that interprets QWIRE circuits as superoperators on density matrices, and prove the correctness of some simple quantum programs.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2018a"></a><pre>
@phdthesis{<a href="bbt.html#Rand2018a">Rand2018a</a>,
  title = {Formally {{Verified Quantum Programming}}},
  author = {Rand, Robert},
  year = {2018},
  month = nov,
  school = {University of Pennsylvania},
  address = {{Philadelphia, PA, USA}},
  url = {<a href="https://repository.upenn.edu/edissertations/3175">https://repository.upenn.edu/edissertations/3175</a>},
  abstract = {The field of quantum mechanics predates computer science by at least ten years, the time between the publication of the Schrodinger equation and the Church-Turing thesis. It took another fifty years for Feynman to recognize that harnessing quantum mechanics is necessary to efficiently simulate physics and for David Deutsch to propose the quantum Turing machine. After thirty more years, we are finally getting close to the first general-purpose quantum computers based upon prototypes by IBM, Intel, Google and others.

               While physicists and engineers have worked on building scalable quantum computers, theoretical computer scientists have made their own advances. Complexity theorists introduced quantum complexity classes like BQP and QMA; Shor and Grover developed their famous algorithms for factoring and unstructured search. Programming languages researchers pursued two main research directions: Small-scale languages like QPL and the quantum lambda-calculi for reasoning about quantum computation and large-scale languages like Quipper and Q\# for industrial-scale quantum software development. This thesis aims to unify these two threads while adding a third one: formal verification.

               We argue that quantum programs demand machine-checkable proofs of correctness. We justify this on the basis of the complexity of programs manipulating quantum states, the expense of running quantum programs, and the inapplicability of traditional debugging techniques to programs whose states cannot be examined. We further argue that the existing mathematical models of quantum computation make this an easier task than one could reasonably expect. In light of these observations we introduce QWIRE, a tool for writing verifiable, large scale quantum programs.

               QWIRE is not merely a language for writing and verifying quantum circuits: it is a verified circuit description language. This means that the semantics of QWIRE circuits are verified in the Coq proof assistant. We also implement verified abstractions, like ancilla management and reversible circuit compilation. Finally, we turn QWIRE and Coq's abilities outwards, towards verifying popular quantum algorithms like quantum teleportation. We argue that this tool provides a solid foundation for research into quantum programming languages and formal verification going forward.},
  note = {Publicly Accessible Penn Dissertations. 3175},
  webnote = {Publicly Accessible Penn Dissertations. 3175. See Ch. 3 for ``A Brief History of Quantum Programming and Verification'', which is an excellent recent survey of the area.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2018b"></a><pre>
@misc{<a href="bbt.html#Rand2018b">Rand2018b</a>,
  title = {Phantom {{Types}} for {{Quantum Programs}}},
  author = {Rand, Robert and Paykin, Jennifer and Zdancewic, Steve},
  year = {2018},
  month = jan,
  url = {<a href="https://popl18.sigplan.org/event/coqpl-2018-phantom-types-for-quantum-programs">https://popl18.sigplan.org/event/coqpl-2018-phantom-types-for-quantum-programs</a>},
  abstract = {We explore the design space of using dependent types to type check and verify quantum circuits. We weigh the trade-offs between the expressivity of dependent types against the costs imposed by large proof terms. We propose lightweight dependent types, or phantom types, as a middle ground, which provide useful type information for programming while specifying the properties to be externally verified.},
  note = {Talk at The Fourth International Workshop on Coq for Programming Languages (CoqPL '18)},
  webnote = {Talk at The Fourth International Workshop on Coq for Programming Languages (CoqPL '18)},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2019"></a><pre>
@inproceedings{<a href="bbt.html#Rand2019">Rand2019</a>,
  title = {{{ReQWIRE}}: {{Reasoning}} about {{Reversible Quantum Circuits}}},
  shorttitle = {{{ReQWIRE}}},
  author = {Rand, Robert and Paykin, Jennifer and Lee, Dongho and Zdancewic, Steve},
  year = {2019},
  month = jan,
  booktitle = {Proceedings of the 15th International Conference on Quantum Physics and Logic (QPL), Halifax, Canada, June 3--7, 2018},
  editor = {Selinger, Peter and Chiribella, Giulio},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {287},
  pages = {299--312},
  doi = {10.4204/EPTCS.287.17},
  abstract = {Common quantum algorithms make heavy use of ancillae: scratch qubits that are initialized at some state and later returned to that state and discarded. Existing quantum circuit languages let programmers assert that a qubit has been returned to the |0{$>$} state before it is discarded, allowing for a range of optimizations. However, existing languages do not provide the tools to verify these assertions, introducing a potential source of errors. In this paper we present methods for verifying that ancillae are discarded in the desired state, and use these methods to implement a verified compiler from classical functions to quantum oracles.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2019a"></a><pre>
@inproceedings{<a href="bbt.html#Rand2019a">Rand2019a</a>,
  title = {{Formal Verification vs. Quantum Uncertainty}},
  author = {Rand, Robert and Hietala, Kesha and Hicks, Michael},
  year = {2019},
  month = jul,
  booktitle = {3rd Summit on Advances in Programming Languages (SNAPL 2019)},
  editor = {Benjamin S. Lerner and Rastislav Bod{\'i}k and Shriram Krishnamurthi},
  publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
  address = {Dagstuhl, Germany},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {136},
  eid = {12},
  pages = {12:1--12:11},
  doi = {10.4230/LIPIcs.SNAPL.2019.12},
  abstract = {Quantum programming is hard: Quantum programs are necessarily probabilistic and impossible to examine without disrupting the execution of a program. In response to this challenge, we and a number of other researchers have written tools to verify quantum programs against their intended semantics. This is not enough. Verifying an idealized semantics against a real world quantum program doesn't allow you to confidently predict the program's output. In order to have verification that works, you need both an error semantics related to the hardware at hand (this is necessarily low level) and certified compilation to the that same hardware. Once we have these two things, we can talk about an approach to quantum programming where we start by writing and verifying programs at a high level, attempt to verify properties of the compiled code, and repeat as necessary.},
  keywords = {formal verification, quantum computing, programming languages, quantum error correction, certified compilation, nisq},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rand2021"></a><pre>
@inproceedings{<a href="bbt.html#Rand2021">Rand2021</a>,
  title = {Gottesman Types for Quantum Programs},
  author = {Rand, Robert and Sundaram, Aarthi and Singhal, Kartik and Lackey, Brad},
  year = {2021},
  month = sep,
  booktitle = {Proceedings of the 17th International Conference on Quantum Physics and Logic (QPL), Paris, France, June 2--6, 2020},
  editor = {Valiron, Beno{\^i}t and Mansfield, Shane and Arrighi, Pablo and Panangaden, Prakash},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {340},
  pages = {279--290},
  doi = {10.4204/EPTCS.340.14},
  url = {<a href="https://rand.cs.uchicago.edu/publication/rand-2020-gottesman/">https://rand.cs.uchicago.edu/publication/rand-2020-gottesman/</a>},
  abstract = {The Heisenberg representation of quantum operators provides a powerful technique for reasoning about quantum circuits, albeit those restricted to the common (non-universal) Clifford set H, S and CNOT. The Gottesman-Knill theorem showed that we can use this representation to efficiently simulate Clifford circuits. We show that Gottesman's semantics for quantum programs can be treated as a type system, allowing us to efficiently characterize a common subset of quantum programs. We also show that it can be extended beyond the Clifford set to partially characterize a broad range of programs. We apply these types to reason about separable states and the superdense coding algorithm.},
  keywords = {quantum computing, type systems, gottesman types},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rennela2018"></a><pre>
@inproceedings{<a href="bbt.html#Rennela2018">Rennela2018</a>,
  title = {Classical {{Control}} and {{Quantum Circuits}} in {{Enriched Category Theory}}},
  author = {Rennela, Mathys and Staton, Sam},
  year = {2018},
  month = apr,
  booktitle = {The Thirty-Third Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXIII)},
  publisher = {Elsevier},
  series = {Electronic Notes in Theoretical Computer Science},
  volume = {336},
  pages = {257--279},
  doi = {10.1016/j.entcs.2018.03.027},
  abstract = {We describe categorical models of a circuit-based (quantum) functional programming language. We show that enriched categories play a crucial role. Following earlier work on QWire by Paykin et al., we consider both a simple first-order linear language for circuits, and a more powerful host language, such that the circuit language is embedded inside the host language. Our categorical semantics for the host language is standard, and involves cartesian closed categories and monads. We interpret the circuit language not in an ordinary category, but in a category that is enriched in the host category. As an extended example, we recall an earlier result that the category of W*-algebras is dcpo-enriched, and we use this model to extend the circuit language with some recursive types.},
  keywords = {enriched categories, categorical semantics, linear type theory, quantum circuits, relative monad, quantum domain theory},
  webnote = {See also the later version: \cite{Rennela2020}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rennela2020"></a><pre>
@article{<a href="bbt.html#Rennela2020">Rennela2020</a>,
  title = {{Classical Control, Quantum Circuits and Linear Logic in Enriched Category Theory}},
  author = {Rennela, Mathys and Staton, Sam},
  year = {2020},
  month = mar,
  journal = {Logical Methods in Computer Science},
  volume = {16},
  number = {1},
  eid = {30},
  pages = {30},
  doi = {10.23638/LMCS-16(1:30)2020},
  abstract = {We describe categorical models of a circuit-based (quantum) functional programming language. We show that enriched categories play a crucial role. Following earlier work on QWire by Paykin et al., we consider both a simple first-order linear language for circuits, and a more powerful host language, such that the circuit language is embedded inside the host language. Our categorical semantics for the host language is standard, and involves cartesian closed categories and monads. We interpret the circuit language not in an ordinary category, but in a category that is enriched in the host category. We show that this structure is also related to linear/non-linear models. As an extended example, we recall an earlier result that the category of W*-algebras is dcpo-enriched, and we use this model to extend the circuit language with some recursive types.},
  keywords = {programming languages, category theory, operator algebras},
  webnote = {Expands and develops upon \cite{Rennela2018}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rios2018"></a><pre>
@inproceedings{<a href="bbt.html#Rios2018">Rios2018</a>,
  title = {A Categorical Model for a Quantum Circuit Description Language (Extended Abstract)},
  author = {Rios, Francisco and Selinger, Peter},
  year = {2018},
  month = feb,
  booktitle = {Proceedings of the 14th International Conference on Quantum Physics and Logic (QPL), Nijmegen, the Netherlands, July 3--7, 2017},
  editor = {Coecke, Bob and Kissinger, Aleks},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {266},
  pages = {164--178},
  doi = {10.4204/EPTCS.266.11},
  abstract = {Quipper is a practical programming language for describing families of quantum circuits. In this paper, we formalize a small, but useful fragment of Quipper called Proto-Quipper-M. Unlike its parent Quipper, this language is type-safe and has a formal denotational and operational semantics. Proto-Quipper-M is also more general than Quipper, in that it can describe families of morphisms in any symmetric monoidal category, of which quantum circuits are but one example. We design Proto-Quipper-M from the ground up, by first giving a general categorical model of parameters and state. The distinction between parameters and state is also known from hardware description languages. A parameter is a value that is known at circuit generation time, whereas a state is a value that is known at circuit execution time. After finding some interesting categorical structures in the model, we then define the programming language to fit the model. We cement the connection between the language and the model by proving type safety, soundness, and adequacy properties.},
  keywords = {proto-quipper-m, quipper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Rios2021"></a><pre>
@phdthesis{<a href="bbt.html#Rios2021">Rios2021</a>,
  title = {On a Categorically Sound Quantum Programming Language for Circuit Description},
  author = {Rios, Francisco},
  year = {2021},
  month = aug,
  school = {Dalhousie University},
  address = {{Halifax, Nova Scotia, Canada}},
  url = {<a href="https://dalspace.library.dal.ca/handle/10222/80771">https://dalspace.library.dal.ca/handle/10222/80771</a>},
  abstract = {This thesis contains contributions to the mathematical foundations of quantum programming languages.

               The likely arrival of scalable quantum computers in the not so distant future has resulted in a flurry of activity in the development of quantum programming languages. As in classical computing, the transition from a description of a quantum algorithm found in the literature to a hardware-specific set of instructions run on a quantum device is a complex process, prone to errors. This issue is exacerbated in the quantum setting not only by the complexity of quantum algorithms but also by the fragility of quantum information, which renders ineffective some of the classical techniques used to debug programs.

               In this thesis, we contribute to the solution of some of these issues. We introduce Proto-Quipper-M, a new quantum  programming language designed to serve as a testbed for the research and development of sound mathematical semantics and reasoning techniques for quantum programs. We first present Proto-Quipper-M as a formalization of a fragment of Quipper, a high-level functional programming language for describing families of quantum circuits. In particular, we define Proto-Quipper-M as a simply-typed lambda calculus with a special type for quantum circuits and a strong type system designed to enforce linearity on quantum data, and thus prevent violations of the no-cloning property of quantum information. We endow ProtoQuipper-M with computational meaning via a big-step operational semantics and prove that the language is type-safe by showing that it enjoys the type-preservation and error-freeness properties. We also give Proto-Quipper-M a denotational semantics in a suitable class of monoidal categories and show that these categories give rise to linear-non-linear models in the sense of Benton, and thus models of intuitionistic linear logic. Finally, we crystallize the connection between the syntax and the semantics of the language by proving the soundness theorem for Proto-Quipper-M.},
  keywords = {quantum programming languages, categorical model, quantum circuits, proto-quipper-m, category theory, quantum computing, quipper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ross2015"></a><pre>
@phdthesis{<a href="bbt.html#Ross2015">Ross2015</a>,
  title = {Algebraic and {{Logical Methods}} in {{Quantum Computation}}},
  author = {Ross, Neil J.},
  year = {2015},
  month = aug,
  school = {Dalhousie University},
  address = {{Halifax, Nova Scotia, Canada}},
  archiveprefix = {arXiv},
  eprint = {1510.02198},
  abstract = {This thesis contains contributions to the theory of quantum computation. We first define a new method to efficiently approximate special unitary operators. Specifically, given a special unitary U and a precision {\epsilon} > 0, we show how to efficiently find a sequence of Clifford+V or Clifford+T operators whose product approximates U up to {\epsilon} in the operator norm. In the general case, the length of the approximating sequence is asymptotically optimal. If the unitary to approximate is diagonal then our method is optimal: it yields the shortest sequence approximating U up to {\epsilon}. Next, we introduce a mathematical formalization of a fragment of the Quipper quantum programming language. We define a typed lambda calculus called Proto-Quipper which formalizes a restricted but expressive fragment of Quipper. The type system of Proto-Quipper is based on intuitionistic linear logic and prohibits the duplication of quantum data, in accordance with the no-cloning property of quantum computation. We prove that Proto-Quipper is type-safe in the sense that it enjoys the subject reduction and progress properties.},
  keywords = {proto-quipper-s, proto-quipper, quipper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ruediger2007"></a><pre>
@article{<a href="bbt.html#Ruediger2007">Ruediger2007</a>,
  title = {Quantum {{Programming Languages}}: {{An Introductory Overview}}},
  shorttitle = {Quantum {{Programming Languages}}},
  author = {R{\"u}diger, Roland},
  year = {2007},
  month = mar,
  journal = {The Computer Journal},
  volume = {50},
  number = {2},
  pages = {134--150},
  doi = {10.1093/comjnl/bxl057},
  abstract = {The present article gives an introductory overview of the novel field of quantum programming languages (QPLs) from a pragmatic perspective. First, after a short summary of basic notations of quantum mechanics, some of the goals and design issues are surveyed, which motivate the research in this area. Then, several of the approaches are described in more detail. The article concludes with a brief survey of current research activities and a tabular summary of a selection of QPLs, which have been published so far.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Sabry2018"></a><pre>
@inproceedings{<a href="bbt.html#Sabry2018">Sabry2018</a>,
  title = {From Symmetric Pattern-Matching to Quantum Control},
  author = {Sabry, Amr and Valiron, Beno{\^i}t and Vizzotto, Juliana Kaizer},
  year = {2018},
  month = apr,
  booktitle = {Foundations of Software Science and Computation Structures, FoSSaCS 2018},
  editor = {Baier, Christel and Dal Lago, Ugo},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  series = {Lecture Notes in Computer Science},
  volume = {10803},
  pages = {348--364},
  doi = {10.1007/978-3-319-89366-2_19},
  archiveprefix = {arXiv},
  eprint = {1804.00952},
  abstract = {One perspective on quantum algorithms is that they are classical algorithms having access to a special kind of memory with exotic properties. This perspective suggests that, even in the case of quantum algorithms, the control flow notions of sequencing, conditionals, loops, and recursion are entirely classical. There is however, another notion of control flow, that is itself quantum. The notion of quantum conditional expression is reasonably well-understood: the execution of the two expressions becomes itself a superposition of executions. The quantum counterpart of loops and recursion is however not believed to be meaningful in its most general form.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Selinger2004"></a><pre>
@inproceedings{<a href="bbt.html#Selinger2004">Selinger2004</a>,
  title = {A {{Brief Survey}} of {{Quantum Programming Languages}}},
  author = {Selinger, Peter},
  year = {2004},
  month = apr,
  booktitle = {Proceedings of the 7th International Symposium on Functional and Logic Programming},
  editor = {Kameyama, Yukiyoshi and Stuckey, Peter J.},
  publisher = {Springer},
  address = {{Berlin, Heidelberg}},
  series = {Lecture Notes in Computer Science},
  volume = {2998},
  pages = {1--6},
  doi = {10.1007/978-3-540-24754-8_1},
  abstract = {This article is a brief and subjective survey of quantum programming language research.},
  keywords = {quantum computation, quantum algorithm, linear logic, denotational semantics, lambda calculus},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Selinger2004a"></a><pre>
@article{<a href="bbt.html#Selinger2004a">Selinger2004a</a>,
  title = {Towards a Quantum Programming Language},
  author = {Selinger, Peter},
  year = {2004},
  month = aug,
  journal = {Mathematical Structures in Computer Science},
  volume = {14},
  number = {4},
  pages = {527--586},
  doi = {10.1017/S0960129504004256},
  url = {<a href="https://www.mathstat.dal.ca/~selinger/papers/papers/qpl.pdf">https://www.mathstat.dal.ca/~selinger/papers/papers/qpl.pdf</a>},
  abstract = {We propose the design of a programming language for quantum computing. Traditionally, quantum algorithms are frequently expressed at the hardware level, for instance in terms of the quantum circuit model or quantum Turing machines. These approaches do not encourage structured programming or abstractions such as data types. In this paper, we describe the syntax and semantics of a simple quantum programming language with high-level features such as loops, recursive procedures, and structured data types. The language is functional in nature, statically typed, free of run-time errors, and has an interesting denotational semantics in terms of complete partial orders of superoperators.},
  webnote = {Introduces Quantum Flow Charts (QFC) and QPL},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Selinger2006"></a><pre>
@article{<a href="bbt.html#Selinger2006">Selinger2006</a>,
  title = {A Lambda Calculus for Quantum Computation with Classical Control},
  author = {Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2006},
  month = jun,
  journal = {Mathematical Structures in Computer Science},
  volume = {16},
  number = {3},
  pages = {527--552},
  doi = {10.1017/S0960129506005238},
  url = {<a href="https://www.mscs.dal.ca/~selinger/papers/papers/qlambda-mscs.pdf">https://www.mscs.dal.ca/~selinger/papers/papers/qlambda-mscs.pdf</a>},
  abstract = {In this paper we develop a functional programming language for quantum computers by extending the simply-typed lambda calculus with quantum types and operations. The design of this language adheres to the 'quantum data, classical control' paradigm, following the first author's work on quantum flow-charts. We define a call-by-value operational semantics, and give a type system using affine intuitionistic linear logic. The main results of this paper are the safety properties of the language and the development of a type inference algorithm.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Selinger2007"></a><pre>
@article{<a href="bbt.html#Selinger2007">Selinger2007</a>,
  title = {Dagger Compact Closed Categories and Completely Positive Maps (Extended Abstract)},
  author = {Selinger, Peter},
  year = {2007},
  month = mar,
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {170},
  pages = {139--163},
  doi = {j.entcs.2006.12.018},
  url = {<a href="https://www.mscs.dal.ca/~selinger/papers/dagger.pdf">https://www.mscs.dal.ca/~selinger/papers/dagger.pdf</a>},
  abstract = {Dagger compact closed categories were recently introduced by Abramsky and Coecke, under the name ``strongly compact closed categories'', as an axiomatic framework for quantum mechanics. We present a graphical language for dagger compact closed categories, and sketch a proof of its completeness for equational reasoning. We give a general construction, the CPM construction, which associates to each dagger compact closed category its ``category of completely positive maps'', and we show that the resulting category is again dagger compact closed. We apply these ideas to Abramsky and Coecke's interpretation of quantum protocols, and to D'Hondt and Panangaden's predicate transformer semantics.},
  keywords = {categorical model, quantum computing, dagger categories, cpm construction},
  note = {Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005)},
  webnote = {QPL 2005},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Selinger2009"></a><pre>
@incollection{<a href="bbt.html#Selinger2009">Selinger2009</a>,
  title = {Quantum {{Lambda Calculus}}},
  author = {Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  pages = {135--172},
  crossref = {<a href="#Gay2009">Gay2009</a>},
  doi = {10.1017/CBO9781139193313.005},
  url = {<a href="https://www.mscs.dal.ca/~selinger/papers/qlambdabook.pdf">https://www.mscs.dal.ca/~selinger/papers/qlambdabook.pdf</a>},
  abstract = {We discuss the design of a typed lambda calculus for quantum computation. After a brief discussion of the role of higher-order functions in quantum information theory, we define the quantum lambda calculus and its operational semantics. Safety invariants, such as the no-cloning property, are enforced by a static type system that is based on intuitionistic linear logic. We also describe a type inference algorithm, and a categorical semantics.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Singhal2020"></a><pre>
@inproceedings{<a href="bbt.html#Singhal2020">Singhal2020</a>,
  title = {Verified translation between low-level quantum languages},
  author = {Singhal, Kartik and Rand, Robert and Hicks, Michael},
  year = {2020},
  month = jan,
  booktitle = {First International Workshop on Programming Languages for Quantum Computing (PLanQC '20)},
  url = {<a href="https://ks.cs.uchicago.edu/publication/verified-translation/">https://ks.cs.uchicago.edu/publication/verified-translation/</a>},
  abstract = {We describe the ongoing development of a verified translator between OpenQASM (Open Quantum Assembly Language) and sqir, a Small Quantum Intermediate Representation used for circuit optimization. Verified translation from and to OpenQASM will allow verified optimization of circuits written in a variety of tools and executed on real quantum computers. This translator is a step toward a verified compilation stack for quantum computing.},
  keywords = {formal verification, nisq, program proof, programming languages, semantic preservation, openqasm, qasm, quantum computing},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Singhal2020a"></a><pre>
@mastersthesis{<a href="bbt.html#Singhal2020a">Singhal2020a</a>,
  title = {Quantum Hoare Type Theory},
  author = {Singhal, Kartik},
  year = {2020},
  month = dec,
  school = {University of Chicago},
  address = {Chicago, IL},
  archiveprefix = {arXiv},
  eprint = {2012.02154},
  url = {<a href="https://ks.cs.uchicago.edu/publication/qhtt-masters/">https://ks.cs.uchicago.edu/publication/qhtt-masters/</a>},
  abstract = {As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs. Inspired by Hoare Type Theory in classical computing, we propose Quantum Hoare Type Theory (QHTT), in which precise specifications about the modification to the quantum state can be provided within the type of computation. These specifications within a Hoare type are given in the form of Hoare-logic style pre- and postconditions following the propositions-as-types principle. The type-checking process verifies that the implementation conforms to the provided specification. QHTT has the potential to be a unified system for programming, specifying, and reasoning about quantum programs.},
  keywords = {formal verification, program proof, programming languages, quantum computing, quantum computation, type systems, type theory, pre- and postconditions, program specifications, hoare logic, separation logic},
  webnote = {See also: \cite{Singhal2021a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Singhal2021"></a><pre>
@inproceedings{<a href="bbt.html#Singhal2021">Singhal2021</a>,
  title = {Toward a Type-Theoretic Interpretation of Q\# and Statically Enforcing the No-Cloning Theorem},
  author = {Singhal, Kartik and Marshall, Sarah and Hietala, Kesha and Rand, Robert},
  year = {2021},
  month = jun,
  booktitle = {Second International Workshop on Programming Languages for Quantum Computing (PLanQC '21)},
  url = {<a href="https://ks.cs.uchicago.edu/publication/tttiq/">https://ks.cs.uchicago.edu/publication/tttiq/</a>},
  abstract = {Q\# is a high-level programming language from Microsoft for writing and running quantum programs. Like most industrial languages, it was designed without a formal specification, which can naturally lead to ambiguity in its interpretation. Further, currently, the Q\# type system cannot statically prevent cloning of qubits. We aim to provide a formal specification and semantics for Q\#, placing the language on a solid mathematical foundation, enabling further evolution of its design and type system (including enforcing no-cloning). This paper describes our current progress in designing λ-Q\# (an idealized version of Q\#), our solution to the qubit cloning problem in λ-Q\#, and outlines the next steps.},
  keywords = {quantum computing, quantum computation, programming languages, formal specification, formal language definitions, type systems, semantics and reasoning, quantum programming languages, language design, q\#},
  webnote = {See also: \cite{Singhal2022}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Singhal2021a"></a><pre>
@inproceedings{<a href="bbt.html#Singhal2021a">Singhal2021a</a>,
  title = {Quantum Hoare Type Theory: Extended Abstract},
  author = {Singhal, Kartik and Reppy, John},
  year = {2021},
  month = sep,
  booktitle = {Proceedings of the 17th International Conference on Quantum Physics and Logic (QPL), Paris, France, June 2--6, 2020},
  editor = {Valiron, Beno{\^i}t and Mansfield, Shane and Arrighi, Pablo and Panangaden, Prakash},
  publisher = {{Open Publishing Association}},
  address = {Waterloo, NSW, Australia},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {340},
  pages = {291--302},
  doi = {10.4204/EPTCS.340.15},
  url = {<a href="https://ks.cs.uchicago.edu/publication/qhtt/">https://ks.cs.uchicago.edu/publication/qhtt/</a>},
  abstract = {As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs. In classical computing, formal verification and sound static type systems prevent several classes of bugs from being introduced. There is a need for similar techniques in the quantum regime. Inspired by Hoare Type Theory in the classical paradigm, we propose Quantum Hoare Types by extending the Quantum IO Monad by indexing it with pre- and post-conditions that serve as program specifications. In this paper, we introduce Quantum Hoare Type Theory (QHTT), present its syntax and typing rules, and demonstrate its effectiveness with the help of examples. QHTT has the potential to be a unified system for programming, specifying, and reasoning about quantum programs. This is a work in progress.},
  keywords = {formal verification, program proof, programming languages, quantum computing, type systems, type theory, pre- and postconditions, program specifications, hoare logic, separation logic},
  webnote = {Also see expanded version: \cite{Singhal2020a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Singhal2022"></a><pre>
@inproceedings{<a href="bbt.html#Singhal2022">Singhal2022</a>,
  title = {{Q\# as a Quantum Algorithmic Language}},
  author = {Singhal, Kartik and Hietala, Kesha and Marshall, Sarah and Rand, Robert},
  year = {2022},
  month = jun,
  booktitle = {Proceedings of the 19th International Conference on Quantum Physics and Logic (QPL), Oxford, U.K., June 27--July 1, 2022},
  publisher = {{Open Publishing Association}},
  archiveprefix = {arXiv},
  eprint = {2206.03532},
  url = {<a href="https://ks.cs.uchicago.edu/publication/q-algol/">https://ks.cs.uchicago.edu/publication/q-algol/</a>},
  abstract = {Q\# is a standalone domain-specific programming language from Microsoft for writing and running quantum programs. Like most industrial languages, it was designed without a formal specification, which can naturally lead to ambiguity in its interpretation. We aim to provide a formal language definition for Q\#, placing the language on a solid mathematical foundation and enabling further evolution of its design and type system. This paper presents λ-Q\#, an idealized version of Q\# that illustrates how we may view Q\# as a quantum Algol (algorithmic language). We show the safety properties enforced by λ-Q\#'s type system and present its equational semantics based on a fully complete algebraic theory by Staton.},
  keywords = {quantum computing, quantum computation, programming languages, formal specification, formal language definitions, type systems, semantics and reasoning, quantum programming languages, language design, q\#},
  note = {To appear},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Sivarajah2020"></a><pre>
@article{<a href="bbt.html#Sivarajah2020">Sivarajah2020</a>,
  title = {t$|$ket$\rangle$: a retargetable compiler for {NISQ} devices},
  author = {Sivarajah, Seyon and Dilkes, Silas and Cowtan, Alexander and Simmons, Will and Edgington, Alec and Duncan, Ross},
  year = {2020},
  month = nov,
  journal = {Quantum Science and Technology},
  publisher = {{IOP Publishing}},
  volume = {6},
  number = {1},
  eid = {014003},
  pages = {014003},
  doi = {10.1088/2058-9565/ab8e92},
  archiveprefix = {arXiv},
  eprint = {2003.10611},
  url = {<a href="https://github.com/CQCL/pytket">https://github.com/CQCL/pytket</a>},
  abstract = {We present t$|$ket$\rangle$, a quantum software development platform produced by Cambridge Quantum Computing Ltd. The heart of t$|$ket$\rangle$ is a language-agnostic optimising compiler designed to generate code for a variety of NISQ devices, which has several features designed to minimise the influence of device error. The compiler has been extensively benchmarked and outperforms most competitors in terms of circuit optimisation and qubit routing.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Smith2016"></a><pre>
@misc{<a href="bbt.html#Smith2016">Smith2016</a>,
  title = {A {{Practical Quantum Instruction Set Architecture}}},
  author = {Smith, Robert S. and Curtis, Michael J. and Zeng, William J.},
  year = {2016},
  month = aug,
  archiveprefix = {arXiv},
  eprint = {1608.03355},
  url = {<a href="https://github.com/rigetti/quil">https://github.com/rigetti/quil</a>},
  abstract = {We introduce an abstract machine architecture for classical/quantum computations---including compilation---along with a quantum instruction language called Quil for explicitly writing these computations. With this formalism, we discuss concrete implementations of the machine and non-trivial algorithms targeting them. The introduction of this machine dovetails with ongoing development of quantum computing technology, and makes possible portable descriptions of recent classical/quantum algorithms.},
  webnote = {Introduces Quil, a quantum instruction language},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Staton2015"></a><pre>
@inproceedings{<a href="bbt.html#Staton2015">Staton2015</a>,
  title = {Algebraic Effects, Linearity, and Quantum Programming Languages},
  author = {Staton, Sam},
  year = {2015},
  month = jan,
  booktitle = {Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {POPL '15},
  pages = {395--406},
  numpages = {12},
  doi = {10.1145/2676726.2676999},
  url = {<a href="http://www.cs.ox.ac.uk/people/samuel.staton/papers/popl2015.pdf">http://www.cs.ox.ac.uk/people/samuel.staton/papers/popl2015.pdf</a>},
  abstract = {We develop a new framework of algebraic theories with linear parameters, and use it to analyze the equational reasoning principles of quantum computing and quantum programming languages. We use the framework as follows: we present a new elementary algebraic theory of quantum computation, built from unitary gates and measurement; we provide a completeness theorem or the elementary algebraic theory by relating it with a model from operator algebra; we extract an equational theory for a quantum programming language from the algebraic theory; we compare quantum computation with other local notions of computation by investigating variations on the algebraic theory.},
  keywords = {monads, quantum computation, algebraic effects},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Steiger2018"></a><pre>
@article{<a href="bbt.html#Steiger2018">Steiger2018</a>,
  title = {{{ProjectQ}}: An Open Source Software Framework for Quantum Computing},
  shorttitle = {{{ProjectQ}}},
  author = {Steiger, Damian S. and H{\"a}ner, Thomas and Troyer, Matthias},
  year = {2018},
  month = jan,
  journal = {Quantum},
  volume = {2},
  eid = {49},
  pages = {49},
  doi = {10.22331/q-2018-01-31-49},
  abstract = {We introduce ProjectQ, an open source software effort for quantum computing. The first release features a compiler framework capable of targeting various types of hardware, a high-performance simulator with emulation capabilities, and compiler plug-ins for circuit drawing and resource estimation. We introduce our Python-embedded domain-specific language, present the features, and provide example implementations for quantum algorithms. The framework allows testing of quantum algorithms through simulation and enables running them on actual quantum hardware using a back-end connecting to the IBM Quantum Experience cloud service. Through extension mechanisms, users can provide back-ends to further quantum hardware, and scientists working on quantum compilation can provide plug-ins for additional compilation, optimization, gate synthesis, and layout strategies.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Svore2004"></a><pre>
@inproceedings{<a href="bbt.html#Svore2004">Svore2004</a>,
  title = {Toward a Software Architecture for Quantum Computing Design Tools},
  author = {Svore, Krysta M. and Cross, Andrew W. and Aho, Alfred V. and Chuang, Isaac L. and Markov, Igor L.},
  year = {2004},
  month = jul,
  booktitle = {Proceedings of the 2nd International Workshop on Quantum Programming Languages (QPL), Turku, Finland, July 12--13, 2004},
  pages = {145--162},
  url = {<a href="https://www.mathstat.dal.ca/~selinger/qpl2004/PDFS/10Svore-Cross-Aho-Chuang-Markov.pdf">https://www.mathstat.dal.ca/~selinger/qpl2004/PDFS/10Svore-Cross-Aho-Chuang-Markov.pdf</a>},
  abstract = {Compilers and computer-aided design tools will be essential for quantum computing. We present a computer-aided design flow that transforms a high-level language program representing a quantum computing algorithm into a technology-specific implementation. We trace the significant steps in this flow and illustrate the transformations to the representation of the quantum program. The focus of this paper is on the languages and transformations needed to represent and optimize a quantum algorithm along the design flow. Our software architecture provides significant benefits to algorithm designers, tool builders, and experimentalists. Of particular interest are the trade-offs in performance and accuracy that can be obtained by weighing different optimization and error-correction procedures at given levels in the design hierarchy.},
  webnote = {See also: \cite{Svore2006}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Svore2006"></a><pre>
@article{<a href="bbt.html#Svore2006">Svore2006</a>,
  title = {A Layered Software Architecture for Quantum Computing Design Tools},
  author = {Svore, Krysta M. and Aho, Alfred V. and Cross, Andrew W. and Chuang, Isaac L. and Markov, Igor L.},
  year = {2006},
  month = jan,
  journal = {Computer},
  volume = {39},
  number = {1},
  pages = {74--83},
  doi = {10.1109/MC.2006.4},
  url = {<a href="https://web.eecs.umich.edu/~imarkov/pubs/jour/computer06-q.pdf">https://web.eecs.umich.edu/~imarkov/pubs/jour/computer06-q.pdf</a>},
  abstract = {Compilers and computer-aided design tools are essential for fine-grained control of nanoscale quantum-mechanical systems. A proposed four-phase design flow assists with computations by transforming a quantum algorithm from a high-level language program into precisely scheduled physical actions.},
  keywords = {quantum computing, design tools, programming languages, software architectures, epr pair creation},
  webnote = {See also: \cite{Svore2004}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Svore2018"></a><pre>
@inproceedings{<a href="bbt.html#Svore2018">Svore2018</a>,
  title = {Q\#: {{Enabling Scalable Quantum Computing}} and {{Development}} with a {{High}}-Level {{DSL}}},
  shorttitle = {Q\#},
  author = {Svore, Krysta M. and Geller, Alan and Troyer, Matthias and Azariah, John and Granade, Christopher E. and Heim, Bettina and Kliuchnikov, Vadym and Mykhailova, Mariia and Paz, Andres and Roetteler, Martin},
  year = {2018},
  month = feb,
  booktitle = {Proceedings of the Real World Domain Specific Languages Workshop 2018},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{RWDSL}} '18},
  eid = {7},
  pages = {7},
  numpages = {10},
  doi = {10.1145/3183895.3183901},
  archiveprefix = {arXiv},
  eprint = {1803.00652},
  abstract = {Quantum computing exploits quantum phenomena such as superposition and entanglement to realize a form of parallelism that is not available to traditional computing. It offers the potential of significant computational speed-ups in quantum chemistry, materials science, cryptography, and machine learning. The dominant approach to programming quantum computers is to provide an existing high-level language with libraries that allow for the expression of quantum programs. This approach can permit computations that are meaningless in a quantum context; prohibits succinct expression of interaction between classical and quantum logic; and does not provide important constructs that are required for quantum programming. We present Q\#, a quantum-focused domain-specific language explicitly designed to correctly, clearly and completely express quantum algorithms. Q\# provides a type system; a tightly constrained environment to safely interleave classical and quantum computations; specialized syntax; symbolic code manipulation to automatically generate correct transformations of quantum operations; and powerful functional constructs which aid composition.},
  keywords = {domain specific language, functional programming, quantum computing, q\#},
  webnote = {See also Ch. 8 of \cite{Heim2020}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Tao2022"></a><pre>
@inproceedings{<a href="bbt.html#Tao2022">Tao2022</a>,
  title = {Giallar: Push-Button Verification for the Qiskit Quantum Compiler},
  author = {Tao, Runzhou and Shi, Yunong and Yao, Jianan and Li, Xupeng and Javadi-Abhari, Ali and Cross, Andrew W. and Chong, Frederic T. and Gu, Ronghui},
  year = {2022},
  month = jun,
  booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{{PLDI}} '22},
  pages = {641--656},
  numpages = {16},
  doi = {10.1145/3519939.3523431},
  archiveprefix = {arXiv},
  eprint = {2205.00661},
  abstract = {This paper presents Giallar, a fully-automated verification toolkit for quantum compilers. Giallar requires no manual specifications, invariants, or proofs, and can automatically verify that a compiler pass preserves the semantics of quantum circuits. To deal with unbounded loops in quantum compilers, Giallar abstracts three loop templates, whose loop invariants can be automatically inferred. To efficiently check the equivalence of arbitrary input and output circuits that have complicated matrix semantics representation, Giallar introduces a symbolic representation for quantum circuits and a set of rewriting rules for reducing symbolic quantum circuits. With Giallar, we implemented and verified 44 (out of 56) compiler passes in 13 versions of the Qiskit compiler, the open-source quantum compiler standard, during which three bugs were detected in and confirmed by Qiskit. Our evaluation shows that most of Qiskit compiler passes can be automatically verified in seconds and verification imposes only a modest overhead to compilation performance.},
  keywords = {quantum computing, compiler verification, automated verification},
  webnote = {Previously known as [CertiQ (arXiv:1908.08963)](https://arxiv.org/abs/1908.08963).},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Unruh2019"></a><pre>
@article{<a href="bbt.html#Unruh2019">Unruh2019</a>,
  title = {Quantum Relational {{Hoare}} Logic},
  author = {Unruh, Dominique},
  year = {2019},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {POPL},
  eid = {33},
  pages = {33},
  numpages = {31},
  doi = {10.1145/3290346},
  archiveprefix = {arXiv},
  eprint = {1802.03188},
  abstract = {We present a logic for reasoning about pairs of interactive quantum programs -- quantum relational Hoare logic (qRHL). This logic follows the spirit of probabilistic relational Hoare logic (Barthe et al. 2009) and allows us to formulate how the outputs of two quantum programs relate given the relationship of their inputs. Probabilistic RHL was used extensively for computer-verified security proofs of classical cryptographic protocols. Since pRHL is not suitable for analyzing quantum cryptography, we present qRHL as a replacement, suitable for the security analysis of post-quantum cryptography and quantum protocols. The design of qRHL poses some challenges unique to the quantum setting, e.g., the definition of equality on quantum registers. Finally, we implemented a tool for verifying proofs in qRHL and developed several example security proofs in it.},
  keywords = {formal verification, quantum cryptography, hoare logic},
  webnote = {POPL '19. See extended version on arXiv.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Unruh2019a"></a><pre>
@inproceedings{<a href="bbt.html#Unruh2019a">Unruh2019a</a>,
  title = {Quantum {{Hoare Logic}} with {{Ghost Variables}}},
  author = {Unruh, Dominique},
  year = {2019},
  month = jun,
  booktitle = {Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science},
  publisher = {{IEEE Computer Society}},
  address = {Los Alamitos, CA, USA},
  series = {{{LICS}} '19},
  eid = {47},
  pages = {47},
  numpages = {13},
  doi = {10.1109/LICS.2019.8785779},
  archiveprefix = {arXiv},
  eprint = {1902.00325},
  abstract = {Quantum Hoare logic allows us to reason about quantum programs. We present an extension of quantum Hoare logic that introduces ``ghost variables'' to extend the expressive power of pre-/postconditions. Ghost variables are variables that do not actually occur in the program and are allowed to have arbitrary quantum states (in a sense, they are existentially quantified), and be entangled with program variables. Ghost variables allow us to express properties such as the distribution of a program variable or the fact that a variable has classical content. And as a case study, we show how quantum Hoare logic with ghost variables can be used to prove the security of the quantum one-time pad.},
  keywords = {quantum entanglement, quantum computing, probabilistic logic, cryptography, semantics, hoare logic},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Unruh2021"></a><pre>
@misc{<a href="bbt.html#Unruh2021">Unruh2021</a>,
  title = {Quantum and classical registers},
  author = {Dominique Unruh},
  year = {2021},
  month = nov,
  archiveprefix = {arXiv},
  eprint = {2105.10914},
  abstract = {We present a generic theory of ``registers'' in imperative programs and instantiate it in the classical and quantum setting. Roughly speaking, a register is some mutable part of the program state. Mutable classical variables and quantum registers and wires in quantum circuits are examples of this. However, registers in our setting can also refer to subparts of other registers, or combinations of parts from different registers, or quantum registers seen in a different basis, etc. Our formalization is intended to be well suited for formalization in theorem provers and as a foundation for modeling quantum/classical variables in imperative programs.
                   We study the quantum registers in greater detail and cover the infinite-dimensional case as well.
                   We implemented a large part of our results (including a minimal quantum Hoare logic and an analysis of quantum teleportation) in the Isabelle/HOL theorem prover.},
  webnote = {See also: Isabelle AFP entry \cite{Unruh2021a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Unruh2021a"></a><pre>
@article{<a href="bbt.html#Unruh2021a">Unruh2021a</a>,
  title = {Quantum and Classical Registers},
  author = {Dominique Unruh},
  year = 2021,
  month = oct,
  journal = {Archive of Formal Proofs},
  volume = {2021},
  url = {<a href="https://isa-afp.org/entries/Registers.html">https://isa-afp.org/entries/Registers.html</a>},
  abstract = {A formalization of the theory of quantum and classical registers as developed by (Unruh, Quantum and Classical Registers). In a nutshell, a register refers to a part of a larger memory or system that can be accessed independently. Registers can be constructed from other registers and several (compatible) registers can be composed. This formalization develops both the generic theory of registers as well as specific instantiations for classical and quantum registers.},
  webnote = {Formal proof development in Isabelle, supplement to \cite{Unruh2021}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Valiron2015"></a><pre>
@article{<a href="bbt.html#Valiron2015">Valiron2015</a>,
  title = {Programming the Quantum Future},
  author = {Valiron, Beno{\^i}t and Ross, Neil J. and Selinger, Peter and Alexander, D. Scott and Smith, Jonathan M.},
  year = {2015},
  month = jul,
  journal = {Communications of the ACM},
  volume = {58},
  number = {8},
  pages = {52--61},
  doi = {10.1145/2699415},
  abstract = {The Quipper language offers a unified general-purpose programming framework for quantum computation.},
  keywords = {quipper},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Vandewetering2020"></a><pre>
@misc{<a href="bbt.html#Vandewetering2020">Vandewetering2020</a>,
  author = {van de Wetering, John},
  title = {{ZX-calculus for the working quantum computer scientist}},
  year = {2020},
  month = dec,
  archiveprefix = {arXiv},
  eprint = {2012.13966},
  abstract = {The ZX-calculus is a graphical language for reasoning about quantum computation that has recently seen an increased usage in a variety of areas such as quantum circuit optimisation, surface codes and lattice surgery, measurement-based quantum computation, and quantum foundations. The first half of this review gives a gentle introduction to the ZX-calculus suitable for those familiar with the basics of quantum computing. The aim here is to make the reader comfortable enough with the ZX-calculus that they could use it in their daily work for small computations on quantum circuits and states. The latter sections give a condensed overview of the literature on the ZX-calculus. We discuss Clifford computation and graphically prove the Gottesman-Knill theorem, we discuss a recently introduced extension of the ZX-calculus that allows for convenient reasoning about Toffoli gates, and we discuss the recent completeness theorems for the ZX-calculus that show that, in principle, all reasoning about quantum computation can be done using ZX-diagrams. Additionally, we discuss the categorical and algebraic origins of the ZX-calculus and we discuss several extensions of the language which can represent mixed states, measurement, classical control and higher-dimensional qudits.},
  keywords = {zx-calculus, category theory},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Vizzotto2006"></a><pre>
@article{<a href="bbt.html#Vizzotto2006">Vizzotto2006</a>,
  title = {Structuring quantum effects: superoperators as arrows},
  author = {Vizzotto, Juliana Kaizer and Altenkirch, Thorsten and Sabry, Amr},
  year = {2006},
  month = jul,
  journal = {Mathematical Structures in Computer Science},
  volume = {16},
  number = {3},
  pages = {453--468},
  doi = {10.1017/S0960129506005287},
  archiveprefix = {arXiv},
  eprint = {quant-ph/0501151},
  abstract = {We show that the model of quantum computation based on density matrices and superoperators can be decomposed into a pure classical (functional) part and an effectful part modelling probabilities and measurement. The effectful part can be modelled using a generalisation of monads called arrows. We express the resulting executable model of quantum computing in the Haskell programming language using its special syntax for arrow computations. However, the embedding in Haskell is not perfect: a faithful model of quantum computing requires type capabilities that are not directly expressible in Haskell.},
  keywords = {arrows},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Vizzotto2009"></a><pre>
@inproceedings{<a href="bbt.html#Vizzotto2009">Vizzotto2009</a>,
  title = {The Arrow Calculus as a Quantum Programming Language},
  author = {Vizzotto, Juliana Kaizer and Du Bois, Andr{\'e} Rauber and Sabry, Amr},
  year = {2009},
  month = jun,
  booktitle = {Logic, Language, Information and Computation},
  editor = {Ono, Hiroakira and Kanazawa, Makoto and de Queiroz, Ruy},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  pages = {379--393},
  doi = {10.1007/978-3-642-02261-6_30},
  abstract = {We express quantum computations (with measurements) using the arrow calculus extended with monadic constructions. This framework expresses quantum programming using well-understood and familiar classical patterns for programming in the presence of computational effects. In addition, the five laws of the arrow calculus provide a convenient framework for equational reasoning about quantum computations that include measurements.},
  keywords = {density matrix, quantum computation, quantum algorithm, functional programming, lambda calculus, arrows},
  webnote = {WoLLIC '09},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Vizzotto2009a"></a><pre>
@inproceedings{<a href="bbt.html#Vizzotto2009a">Vizzotto2009a</a>,
  title = {Reasoning about General Quantum Programs over Mixed States},
  author = {Vizzotto, Juliana Kaizer and Librelotto, Giovani Rubert and Sabry, Amr},
  year = {2009},
  month = nov,
  booktitle = {Formal Methods: Foundations and Applications: 12th Brazilian Symposium on Formal Methods, SBMF 2009 Gramado, Brazil, August 19-21, 2009 Revised Selected Papers},
  editor = {Oliveira, Marcel Vin{\'i}cius Medeiros and Woodcock, Jim},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  pages = {321--335},
  numpages = {15},
  doi = {10.1007/978-3-642-10452-7_22},
  abstract = {In this work we present a functional programming language for quantum computation over mixed states. More interestingly, we develop a set of equations for the resulting programming language, proposing the first framework for equational reasoning about quantum computations over mixed states.},
  keywords = {density matrix, quantum computation, quantum algorithm, quantum circuits, quantum operation},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Voichick2023"></a><pre>
@article{<a href="bbt.html#Voichick2023">Voichick2023</a>,
  title = {Qunity: A Unified Language for Quantum and Classical Computing},
  author = {Voichick, Finn and Li, Liyi and Rand, Robert and Hicks, Michael},
  year = {2022},
  month = apr,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {POPL},
  eid = {},
  pages = {},
  doi = {},
  archiveprefix = {arXiv},
  eprint = {2204.12384},
  url = {<a href="https://gitlab.umiacs.umd.edu/finn/qunity">https://gitlab.umiacs.umd.edu/finn/qunity</a>},
  abstract = {We introduce Qunity, a new quantum programming language designed to treat quantum computing as a natural generalization of classical computing. Qunity presents a unified syntax where familiar programming constructs can have both quantum and classical effects. For example, one can use sum types to implement the direct sum of linear operators, exception handling syntax to implement projective measurements, and aliasing to induce entanglement. Further, Qunity takes advantage of the overlooked BQP subroutine theorem, allowing one to construct reversible subroutines from irreversible quantum algorithms through the uncomputation of "garbage" outputs. Unlike existing languages that enable quantum aspects with separate add-ons (like a classical language with quantum gates bolted on), Qunity provides a unified syntax along with a novel denotational semantics that guarantees that programs are quantum mechanically valid. We present Qunity's syntax, type system, and denotational semantics, showing how it can cleanly express several quantum algorithms. We also detail how Qunity can be compiled to a low-level qubit circuit language like OpenQASM, proving the realizability of our design.},
  keywords = {},
  note = {To appear at POPL '23.},
  webnote = {To appear at POPL '23. See extended version on arXiv.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Wecker2014"></a><pre>
@misc{<a href="bbt.html#Wecker2014">Wecker2014</a>,
  title = {{{LIQ}}$Ui|\rangle$: {{A Software Design Architecture}} and {{Domain}}-{{Specific Language}} for {{Quantum Computing}}},
  author = {Wecker, Dave and Svore, Krysta M.},
  year = {2014},
  month = feb,
  archiveprefix = {arXiv},
  eprint = {1402.4467},
  abstract = {Languages, compilers, and computer-aided design tools will be essential for scalable quantum computing, which promises an exponential leap in our ability to execute complex tasks. LIQ$Ui|\rangle$ is a modular software architecture designed to control quantum hardware. It enables easy programming, compilation, and simulation of quantum algorithms and circuits, and is independent of a specific quantum architecture. LIQ$Ui|\rangle$ contains an embedded, domain-specific language designed for programming quantum algorithms, with F\# as the host language. It also allows the extraction of a circuit data structure that can be used for optimization, rendering, or translation. The circuit can also be exported to external hardware and software environments. Two different simulation environments are available to the user which allow a trade-off between number of qubits and class of operations. LIQ$Ui|\rangle$ has been implemented on a wide range of runtimes as back-ends with a single user front-end. We describe the significant components of the design architecture and how to express any given quantum algorithm.},
  webnote = {Pronounced ``Liquid''},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Xu2022"></a><pre>
@inproceedings{<a href="bbt.html#Xu2022">Xu2022</a>,
  title = {Quartz: Superoptimization of Quantum Circuits},
  author = {Xu, Mingkuan and Li, Zikun and Padon, Oded and Lin, Sina and Pointing, Jessica and Hirth, Auguste and Ma, Henry and Palsberg, Jens and Aiken, Alex and Acar, Umut A. and Jia, Zhihao},
  year = {2022},
  month = jun,
  booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{{PLDI}} '22},
  pages = {625--640},
  numpages = {16},
  doi = {10.1145/3519939.3523433},
  archiveprefix = {arXiv},
  eprint = {2204.09033},
  url = {<a href="https://github.com/quantum-compiler/quartz">https://github.com/quantum-compiler/quartz</a>},
  abstract = {Existing quantum compilers optimize quantum circuits by applying circuit transformations designed by experts. This approach requires significant manual effort to design and implement circuit transformations for different quantum devices, which use different gate sets, and can miss subtle optimizations that are hard to find manually.

                   We propose Quartz, a quantum circuit superoptimizer that automatically generates and verifies circuit transformations for arbitrary quantum gate sets. Quartz takes as input the set of quantum gates supported by a quantum processor and generates candidate circuit transformations for the target processor by enumerating small circuits over the given gate set. Quartz then formally verifies the candidate transformations using an automated theorem prover. Finally, to optimize a quantum circuit, Quartz uses a cost-based backtracking search, applying the verified transformations to the input circuit.

                   Our evaluation on three gate sets supported by existing quantum processors shows that Quartz can effectively generate and verify transformations for different gate sets. The generated transformations cover manually designed transformations used by existing optimizers, and also include new transformations. By using these transformations, Quartz's optimizer matches the performance of existing optimizers on one gate set for which they are tuned, and outperforms them on the two other gate sets.},
  keywords = {quantum computing, superoptimization},
  webnote = {The extended version on arXiv includes an additional appendix with detailed results. Previously known as [Quanto (arXiv:2111.11387)](https://arxiv.org/abs/2111.11387).},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Yan2022"></a><pre>
@article{<a href="bbt.html#Yan2022">Yan2022</a>,
  title = {On Incorrectness Logic for Quantum Programs},
  author = {Yan, Peng and Jiang, Hanru and Yu, Nengkun},
  year = {2022},
  month = apr,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {OOPSLA1},
  eid = {72},
  pages = {72},
  numpages = {28},
  doi = {10.1145/3527316},
  url = {<a href="https://hrjiang.github.io/ilq/">https://hrjiang.github.io/ilq/</a>},
  abstract = {Bug-catching is important for developing quantum programs. Motivated by the incorrectness logic for classical programs, we propose an incorrectness logic towards a logical foundation for static bug-catching in quantum programming. The validity of formulas in this logic is dual to that of quantum Hoare logics. We justify the formulation of validity by an intuitive explanation from a reachability point of view and a comparison against several alternative formulations. Compared with existing works focusing on dynamic analysis, our logic provides sound and complete arguments. We further demonstrate the usefulness of the logic by reasoning several examples, including Grover's search, quantum teleportation, and a repeat-until-success program. We also automate the reasoning procedure by a prototyped static analyzer built on top of the logic rules.},
  keywords = {quantum programming languages, projective quantum predicates, incorrectness logic},
  webnote = {OOPSLA '22. Also see the URL for the extended technical report.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2009"></a><pre>
@incollection{<a href="bbt.html#Ying2009">Ying2009</a>,
  title = {Predicate {{Transformer Semantics}} of {{Quantum Programs}}},
  author = {Ying, Mingsheng and Duan, Runyao and Feng, Yuan and Ji, Zhengfeng},
  year = {2009},
  month = nov,
  booktitle = {Semantic Techniques in Quantum Computation},
  editor = {Gay, Simon J. and Mackie, Ian},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  pages = {311--360},
  crossref = {<a href="#Gay2009">Gay2009</a>},
  doi = {10.1017/CBO9781139193313.009},
  url = {<a href="https://opus.lib.uts.edu.au/bitstream/10453/12965/1/2008004719.pdf">https://opus.lib.uts.edu.au/bitstream/10453/12965/1/2008004719.pdf</a>},
  abstract = {This chapter presents a systematic exposition of predicate transformer semantics for quantum programs. It is divided into two parts: The first part reviews the state transformer (forward) semantics of quantum programs according to Selinger's suggestion of representing quantum programs by superoperators and elucidates D'Hondt-Panangaden's theory of quantum weakest preconditions in detail. In the second part, we develop a quite complete predicate transformer semantics of quantum programs based on Birkhoff-von Neumann quantum logic by considering only quantum predicates expressed by projection operators. In particular, the universal conjunctivity and termination law of quantum programs are proved, and Hoare's induction rule is established in the quantum setting.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2009a"></a><pre>
@misc{<a href="bbt.html#Ying2009a">Ying2009a</a>,
  title = {Hoare Logic for Quantum Programs},
  author = {Ying, Mingsheng},
  year = {2009},
  month = jun,
  archiveprefix = {arXiv},
  eprint = {0906.4586},
  abstract = {Hoare logic is a foundation of axiomatic semantics of classical programs and it provides effective proof techniques for reasoning about correctness of classical programs. To offer similar techniques for quantum program verification and to build a logical foundation of programming methodology for quantum computers, we develop a full-fledged Hoare logic for both partial and total correctness of quantum programs. It is proved that this logic is (relatively) complete by exploiting the power of weakest preconditions and weakest liberal preconditions for quantum programs.},
  webnote = {Early version of \cite{Ying2012}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2012"></a><pre>
@article{<a href="bbt.html#Ying2012">Ying2012</a>,
  title = {Floyd--Hoare {Logic} for {Quantum} {Programs}},
  author = {Ying, Mingsheng},
  year = {2012},
  month = jan,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {33},
  number = {6},
  eid = {19},
  pages = {19},
  numpages = {49},
  doi = {10.1145/2049706.2049708},
  abstract = {Floyd--Hoare logic is a foundation of axiomatic semantics of classical programs, and it provides effective proof techniques for reasoning about correctness of classical programs. To offer similar techniques for quantum program verification and to build a logical foundation of programming methodology for quantum computers, we develop a full-fledged Floyd--Hoare logic for both partial and total correctness of quantum programs. It is proved that this logic is (relatively) complete by exploiting the power of weakest preconditions and weakest liberal preconditions for quantum programs.},
  keywords = {quantum computation, programming languages, axiomatic semantics, floyd--hoare logic, completeness, hoare logic},
  webnote = {An early version is \cite{Ying2009a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2013"></a><pre>
@article{<a href="bbt.html#Ying2013">Ying2013</a>,
  title = {Verification of Quantum Programs},
  author = {Ying, Mingsheng and Yu, Nengkun and Feng, Yuan and Duan, Runyao},
  year = {2013},
  month = sep,
  journal = {Science of Computer Programming},
  volume = {78},
  number = {9},
  pages = {1679--1700},
  doi = {10.1016/j.scico.2013.03.016},
  abstract = {This paper develops verification methodology for quantum programs, and the contribution of the paper is two-fold.

               - Sharir, Pnueli and Hart [M. Sharir, A. Pnueli, S. Hart, Verification of probabilistic programs, SIAM Journal of Computing 13 (1984) 292--314] presented a general method for proving properties of probabilistic programs, in which a probabilistic program is modeled by a Markov chain and an assertion on the output distribution is extended to an invariant assertion on all intermediate distributions. Their method is essentially a probabilistic generalization of the classical Floyd inductive assertion method. In this paper, we consider quantum programs modeled by quantum Markov chains which are defined by super-operators. It is shown that the Sharir-Pnueli-Hart method can be elegantly generalized to quantum programs by exploiting the Schr\"odinger-Heisenberg duality between quantum states and observables. In particular, a completeness theorem for the Sharir-Pnueli-Hart verification method of quantum programs is established.

               - As indicated by the completeness theorem, the Sharir-Pnueli-Hart method is in principle effective for verifying all properties of quantum programs that can be expressed in terms of Hermitian operators (observables). But it is not feasible for many practical applications because of the complicated calculation involved in the verification. For the case of finite-dimensional state spaces, we find a method for verification of quantum programs much simpler than the Sharir-Pnueli-Hart method by employing the matrix representation of super-operators and Jordan decomposition of matrices. In particular, this method enables us to compute easily the average running time and to analyze some interesting long-run behaviors of quantum programs in a finite-dimensional state space.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2014"></a><pre>
@misc{<a href="bbt.html#Ying2014">Ying2014</a>,
  title = {Alternation in {{Quantum Programming}}: {{From Superposition}} of {{Data}} to {{Superposition}} of {{Programs}}},
  shorttitle = {Alternation in {{Quantum Programming}}},
  author = {Ying, Mingsheng and Yu, Nengkun and Feng, Yuan},
  year = {2014},
  month = feb,
  archiveprefix = {arXiv},
  eprint = {1402.5172},
  abstract = {We extract a novel quantum programming paradigm - superposition of programs - from the design idea of a popular class of quantum algorithms, namely quantum walk-based algorithms. The generality of this paradigm is guaranteed by the universality of quantum walks as a computational model. A new quantum programming language QGCL is then proposed to support the paradigm of superposition of programs. This language can be seen as a quantum extension of Dijkstra's GCL (Guarded Command Language). Surprisingly, alternation in GCL splits into two different notions in the quantum setting: classical alternation (of quantum programs) and quantum alternation, with the latter being introduced in QGCL for the first time. Quantum alternation is the key program construct for realizing the paradigm of superposition of programs. The denotational semantics of QGCL are defined by introducing a new mathematical tool called the guarded composition of operator-valued functions. Then the weakest precondition semantics of QGCL can straightforwardly derived. Another very useful program construct in realizing the quantum programming paradigm of superposition of programs, called quantum choice, can be easily defined in terms of quantum alternation. The relation between quantum choices and probabilistic choices is clarified through defining the notion of local variables. We derive a family of algebraic laws for QGCL programs that can be used in program verification, transformations and compilation. The expressive power of QGCL is illustrated by several examples where various variants and generalizations of quantum walks are conveniently expressed using quantum alternation and quantum choice. We believe that quantum programming with quantum alternation and choice will play an important role in further exploiting the power of quantum computing.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2014a"></a><pre>
@misc{<a href="bbt.html#Ying2014a">Ying2014a</a>,
  title = {Quantum Recursion and Second Quantisation},
  author = {Ying, Mingsheng},
  year = {2014},
  month = may,
  archiveprefix = {arXiv},
  eprint = {1405.4443},
  abstract = {This paper introduces a new notion of quantum recursion of which the control flow of the computation is quantum rather than classical as in the notions of recursion considered in the previous studies of quantum programming. A typical example is recursive quantum walks, which are obtained by slightly modifying the construction of the ordinary quantum walks. The operational and denotational semantics of quantum recursions are defined by employing the second quantisation method, and they are proved to be equivalent.},
  note = {Talk at Tsinghua Software Day 2014},
  webnote = {Talk at Tsinghua Software Day 2014.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2016"></a><pre>
@book{<a href="bbt.html#Ying2016">Ying2016</a>,
  title = {Foundations of Quantum Programming},
  author = {Ying, Mingsheng},
  year = {2016},
  month = mar,
  booktitle = {Foundations of Quantum Programming},
  publisher = {{Morgan Kaufmann}},
  address = {{Amsterdam}},
  doi = {10.1016/C2014-0-02660-3},
  abstract = {Foundations of Quantum Programming discusses how new programming methodologies and technologies developed for current computers can be extended to exploit the unique power of quantum computers, which promise dramatic advantages in processing speed over currently available computer systems. Governments and industries around the globe are now investing vast amounts of money with the expectation of building practical quantum computers. Drawing upon years of experience and research in quantum computing research and using numerous examples and illustrations, Mingsheng Ying has created a very useful reference on quantum programming languages and important tools and techniques required for quantum programming, making the book a valuable resource for academics, researchers, and developers.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2017"></a><pre>
@inproceedings{<a href="bbt.html#Ying2017">Ying2017</a>,
  title = {Invariants of Quantum Programs: Characterisations and Generation},
  author = {Ying, Mingsheng and Ying, Shenggang and Wu, Xiaodi},
  year = {2017},
  month = jan,
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{POPL} '17},
  pages = {818--832},
  numpages = {15},
  doi = {10.1145/3009837.3009840},
  url = {<a href="https://opus.lib.uts.edu.au/bitstream/10453/127333/4/p818-ying.pdf">https://opus.lib.uts.edu.au/bitstream/10453/127333/4/p818-ying.pdf</a>},
  abstract = {Program invariant is a fundamental notion widely used in program verification and analysis. The aim of this paper is twofold: (i) find an appropriate definition of invariants for quantum programs; and (ii) develop an effective technique of invariant generation for verification and analysis of quantum programs.  Interestingly, the notion of invariant can be defined for quantum programs in two different ways -- additive invariants and multiplicative invariants -- corresponding to two interpretations of implication in a continuous valued logic: the Lukasiewicz implication and the Godel implication. It is shown that both of them can be used to establish partial correctness of quantum programs.  The problem of generating additive invariants of quantum programs is addressed by reducing it to an SDP (Semidefinite Programming) problem. This approach is applied with an SDP solver to generate invariants of two important quantum algorithms -- quantum walk and quantum Metropolis sampling. Our examples show that the generated invariants can be used to verify correctness of these algorithms and are helpful in optimising quantum Metropolis sampling.  To our knowledge, this paper is the first attempt to define the notion of invariant and to develop a method of invariant generation for quantum programs.},
  keywords = {inductive assertions, quantum programming, partial correctness, invariant generation, program invariants},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2018"></a><pre>
@misc{<a href="bbt.html#Ying2018">Ying2018</a>,
  title = {Reasoning about Parallel Quantum Programs},
  author = {Ying, Mingsheng and Zhou, Li and Li, Yangjia},
  year = {2018},
  month = oct,
  archiveprefix = {arXiv},
  eprint = {1810.11334},
  abstract = {We initiate the study of parallel quantum programming by defining the operational and denotational semantics of parallel quantum programs. The technical contributions of this paper include: (1) find a series of useful proof rules for reasoning about correctness of parallel quantum programs; (2) prove a (relative) completeness of our proof rules for partial correctness of disjoint parallel quantum programs; and (3) prove a strong soundness theorem of the proof rules showing that partial correctness is well maintained at each step of transitions in the operational semantics of a general parallel quantum program (with shared variables). This is achieved by partially overcoming the following conceptual challenges that are never present in classical parallel programming: (i) the intertwining of nondeterminism caused by quantum measurements and introduced by parallelism; (ii) entanglement between component quantum programs; and (iii) combining quantum predicates in the overlap of state Hilbert spaces of component quantum programs with shared variables. Applications of the techniques developed in this paper are illustrated by a formal verification of Bravyi-Gosset-König's parallel quantum algorithm solving a linear algebra problem, which gives for the first time an unconditional proof of a computational quantum advantage.},
  webnote = {See also the published version \cite{Ying2021a}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2021"></a><pre>
@book{<a href="bbt.html#Ying2021">Ying2021</a>,
  title = {Model Checking Quantum Systems: Principles and Algorithms},
  author = {Ying, Mingsheng and Feng, Yuan},
  year = {2021},
  month = jan,
  booktitle = {Model Checking Quantum Systems: Principles and Algorithms},
  publisher = {{Cambridge University Press}},
  address = {Cambridge},
  doi = {10.1017/9781108613323},
  abstract = {Model checking is one of the most successful verification techniques and has been widely adopted in traditional computing and communication hardware and software industries. This book provides the first systematic introduction to model checking techniques applicable to quantum systems, with broad potential applications in the emerging industry of quantum computing and quantum communication as well as quantum physics. Suitable for use as a course textbook and for self-study, graduate and senior undergraduate students will appreciate the step-by-step explanations and the exercises included. Researchers and engineers in the related fields can further develop these techniques in their own work, with the final chapter outlining potential future applications.},
  keywords = {model checking, quantum computing},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2021a"></a><pre>
@article{<a href="bbt.html#Ying2021a">Ying2021a</a>,
  title = {A proof system for disjoint parallel quantum programs},
  author = {Ying, Mingsheng and Zhou, Li and Li, Yangjia and Feng, Yuan},
  year = {2021},
  month = nov,
  journal = {Theoretical Computer Science},
  volume = {897},
  pages = {164--184},
  doi = {10.1016/j.tcs.2021.10.025},
  abstract = {In this paper, we define the operational and denotational semantics of a special class of parallel quantum programs, namely disjoint parallel quantum programs. Based on them, a proof system for reasoning about disjoint parallel quantum programs is developed, which is (relatively) complete even when entanglement between different processes appears in the preconditions and postconditions.},
  keywords = {quantum programming, quantum hoare logic, parallel programs, entanglement, hoare logic},
  webnote = {Essentially the first part of \cite{Ying2018}},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Ying2022"></a><pre>
@misc{<a href="bbt.html#Ying2022">Ying2022</a>,
  title = {{Birkhoff-von Neumann Quantum Logic as an Assertion Language for Quantum Programs}},
  author = {Ying, Mingsheng},
  year = {2022},
  month = may,
  archiveprefix = {arXiv},
  eprint = {2205.01959},
  abstract = {A first-order logic with quantum variables is needed as an assertion language for specifying and reasoning about various properties (e.g. correctness) of quantum programs. Surprisingly, such a logic is missing in the literature, and the existing first-order Birkhoff-von Neumann quantum logic deals with only classical variables and quantifications over them. In this paper, we fill in this gap by introducing a first-order extension of Birkhoff-von Neumann quantum logic with universal and existential quantifiers over quantum variables. Examples are presented to show our logic is particularly suitable for specifying some important properties studied in quantum computation and quantum information. We further incorporate this logic into quantum Hoare logic as an assertion logic so that it can play a role similar to that of first-order logic for classical Hoare logic and BI-logic for separation logic. In particular, we show how it can be used to define and derive quantum generalisations of some adaptation rules that have been applied to significantly simplify verification of classical programs. It is expected that the assertion logic defined in this paper - first-order quantum logic with quantum variables - can be combined with various quantum program logics to serve as a solid logical foundation upon which verification tools can be built using proof assistants such as Coq and Isabelle/HOL.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Yu2021"></a><pre>
@inproceedings{<a href="bbt.html#Yu2021">Yu2021</a>,
  title = {Quantum Abstract Interpretation},
  author = {Yu, Nengkun and Palsberg, Jens},
  year = {2021},
  month = jun,
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {New York, NY, USA},
  series = {{{PLDI}} '21},
  pages = {542--558},
  numpages = {17},
  doi = {10.1145/3453483.3454061},
  url = {<a href="http://web.cs.ucla.edu/~palsberg/paper/pldi21-quantum.pdf">http://web.cs.ucla.edu/~palsberg/paper/pldi21-quantum.pdf</a>},
  abstract = {In quantum computing, the basic unit of information is a qubit. Simulation of a general quantum program takes exponential time in the number of qubits, which makes simulation infeasible beyond 50 qubits on current supercomputers. So, for the understanding of larger programs, we turn to static techniques. In this paper, we present an abstract interpretation of quantum programs and we use it to automatically verify assertions in polynomial time. Our key insight is to let an abstract state be a tuple of projections. For such domains, we present abstraction and concretization functions that form a Galois connection and we use them to define abstract operations. Our experiments on a laptop have verified assertions about the Bernstein-Vazirani, GHZ, and Grover benchmarks with 300 qubits.},
  keywords = {quantum programming, scalability, abstract interpretation},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Yuan2022"></a><pre>
@article{<a href="bbt.html#Yuan2022">Yuan2022</a>,
  title = {Twist: Sound Reasoning for Purity and Entanglement in Quantum Programs},
  author = {Yuan, Charles and McNally, Christopher and Carbin, Michael},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  eid = {30},
  pages = {30},
  numpages = {32},
  doi = {10.1145/3498691},
  archiveprefix = {arXiv},
  eprint = {2205.02287},
  url = {<a href="https://github.com/psg-mit/twist-popl22">https://github.com/psg-mit/twist-popl22</a>},
  abstract = {Quantum programming languages enable developers to implement algorithms for quantum computers that promise computational breakthroughs in classically intractable tasks. Programming quantum computers requires awareness of entanglement, the phenomenon in which measurement outcomes of qubits are correlated. Entanglement can determine the correctness of algorithms and suitability of programming patterns. In this work, we formalize purity as a central tool for automating reasoning about entanglement in quantum programs. A pure expression is one whose evaluation is unaffected by the measurement outcomes of qubits that it does not own, implying freedom from entanglement with any other expression in the computation. We present Twist, the first language that features a type system for sound reasoning about purity. The type system enables the developer to identify pure expressions using type annotations. Twist also features purity assertion operators that state the absence of entanglement in the output of quantum gates. To soundly check these assertions, Twist uses a combination of static analysis and runtime verification. We evaluate Twist's type system and analyses on a benchmark suite of quantum programs in simulation, demonstrating that Twist can express quantum algorithms, catch programming errors in them, and support programs that existing languages disallow, while incurring runtime verification overhead of less than 3.5\%.},
  keywords = {entanglement, purity, quantum programming, type systems},
  webnote = {POPL '22. The extended version on arXiv includes the appendix and differs from ACM Proceedings in that it includes a more refined comparison to prior work, specifically in Sections 3.5 and 9.6.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Yuan2022a"></a><pre>
@article{<a href="bbt.html#Yuan2022a">Yuan2022a</a>,
  title = {Tower: Data Structures in Quantum Superposition},
  author = {Yuan, Charles and Carbin, Michael},
  year = {2022},
  month = sep,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {OOPSLA2},
  eid = {134},
  pages = {134},
  numpages = {30},
  doi = {10.1145/3563297},
  archiveprefix = {arXiv},
  eprint = {2205.10255},
  url = {<a href="https://github.com/psg-mit/tower-oopsla22">https://github.com/psg-mit/tower-oopsla22</a>},
  abstract = {Emerging quantum algorithms for problems such as element distinctness, subset sum, and closest pair demonstrate computational advantages by relying on abstract data structures. Practically realizing such an algorithm as a program for a quantum computer requires an efficient implementation of the data structure whose operations correspond to unitary operators that manipulate quantum superpositions of data.

                   To correctly operate in superposition, an implementation must satisfy three properties -- reversibility, history independence, and bounded-time execution. Standard implementations, such as the representation of an abstract set as a hash table, fail these properties, calling for tools to develop specialized implementations.

                   In this work, we present Core Tower, the first language for quantum programming with random-access memory. Core Tower enables the developer to implement data structures as pointer-based, linked data. It features a reversible semantics enabling every valid program to be translated to a unitary quantum circuit.

                   We present Boson, the first memory allocator that supports reversible, history-independent, and constant-time dynamic memory allocation in quantum superposition. We also present Tower, a language for quantum programming with recursively defined data structures. Tower features a type system that bounds all recursion using classical parameters as is necessary for a program to execute on a quantum computer.

                   Using Tower, we implement Ground, the first quantum library of data structures, including lists, stacks, queues, strings, and sets. We provide the first executable implementation of sets that satisfies all three mandated properties of reversibility, history independence, and bounded-time execution.},
  keywords = {quantum programming, data structures, quantum random-access memory, reversible programming, history independence},
  note = {To appear},
  webnote = {OOPSLA '22. See arXiv version for full paper with appendix.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Zhao2020"></a><pre>
@misc{<a href="bbt.html#Zhao2020">Zhao2020</a>,
  title = {{Quantum Software Engineering}: {Landscapes and Horizons}},
  author = {Zhao, Jianjun},
  year = {2020},
  month = jul,
  archiveprefix = {arXiv},
  eprint = {2007.07047},
  abstract = {Quantum software plays a critical role in exploiting the full potential of quantum computing systems. As a result, it has been drawing increasing attention recently. This paper defines the term ``quantum software engineering'' and introduces a quantum software life cycle. The paper also gives a generic view of quantum software engineering and discusses the quantum software engineering processes, methods, and tools. Based on these, the paper provides a comprehensive survey of the current state of the art in the field and presents the challenges and opportunities we face. The survey summarizes the technology available in the various phases of the quantum software life cycle, including quantum software requirements analysis, design, implementation, test, and maintenance. It also covers the crucial issues of quantum software reuse and measurement.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Zhou2019"></a><pre>
@inproceedings{<a href="bbt.html#Zhou2019">Zhou2019</a>,
  title = {An Applied Quantum {{Hoare}} Logic},
  author = {Zhou, Li and Yu, Nengkun and Ying, Mingsheng},
  year = {2019},
  month = jun,
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  series = {{{PLDI}} '19},
  pages = {1149--1162},
  doi = {10.1145/3314221.3314584},
  url = {<a href="https://opus.lib.uts.edu.au/bitstream/10453/140615/2/3314221.3314584.pdf">https://opus.lib.uts.edu.au/bitstream/10453/140615/2/3314221.3314584.pdf</a>},
  abstract = {We derive a variant of quantum Hoare logic (QHL), called applied quantum Hoare logic (aQHL for short), by: 1. restricting QHL to a special class of preconditions and postconditions, namely projections, which can significantly simplify verification of quantum programs and are much more convenient when used in debugging and testing; and 2. adding several rules for reasoning about robustness of quantum programs, i.e. error bounds of outputs. The effectiveness of aQHL is shown by its applications to verify two sophisticated quantum algorithms: HHL (Harrow-Hassidim-Lloyd) for solving systems of linear equations and qPCA (quantum Principal Component Analysis).},
  keywords = {quantum computation, hoare logic, robustness, projections, programming languages},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Zhou2021"></a><pre>
@inproceedings{<a href="bbt.html#Zhou2021">Zhou2021</a>,
  title = {A Quantum Interpretation of Bunched Logic \& Quantum Separation Logic},
  author = {Zhou, Li and Barthe, Gilles and Hsu, Justin and Ying, Mingsheng and Yu, Nengkun},
  year = {2021},
  month = jul,
  booktitle = {Proceedings of the 36th Annual ACM/IEEE Symposium on Logic in Computer Science},
  publisher = {{IEEE Computer Society}},
  address = {Los Alamitos, CA, USA},
  series = {{{LICS}} '21},
  pages = {1--14},
  doi = {10.1109/LICS52264.2021.9470673},
  archiveprefix = {arXiv},
  eprint = {2102.00329},
  abstract = {We propose a model of the substructural logic of Bunched Implications (BI) that is suitable for reasoning about quantum states. In our model, the separating conjunction of BI describes separable quantum states. We develop a program logic where pre- and post-conditions are BI formulas describing quantum states---the program logic can be seen as a counterpart of separation logic for imperative quantum programs. We exercise the logic for proving the security of quantum one-time pad and secret sharing, and we show how the program logic can be used to discover a flaw in Google Cirq's tutorial on the Variational Quantum Algorithm (VQA).},
  keywords = {formal logic, quantum computing, substructural logic, separating conjunction, separable quantum states, program logic, imperative quantum programs, variational quantum algorithm, quantum interpretation, bunched logic, separation logic},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Zhou2023"></a><pre>
@article{<a href="bbt.html#Zhou2023">Zhou2023</a>,
  title = {CoqQ: Foundational Verification of Quantum Programs},
  author = {Zhou, Li and Barthe, Gilles and Strub, Pierre-Yves and Liu, Junyi and Ying, Mingsheng},
  year = {2022},
  month = jul,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {POPL},
  eid = {},
  pages = {},
  doi = {},
  archiveprefix = {arXiv},
  eprint = {2207.11350},
  url = {<a href="https://github.com/coq-quantum/CoqQ">https://github.com/coq-quantum/CoqQ</a>},
  abstract = {CoqQ is a framework for reasoning about quantum programs in the Coq proof assistant. Its main components are: a deeply embedded quantum programming language, in which classic quantum algorithms are easily expressed, and an expressive program logic for proving properties of programs. CoqQ is foundational: the program logic is formally proved sound with respect to a denotational semantics based on state-of-art mathematical libraries (mathcomp and mathcomp analysis). CoqQ is also practical: assertions can use Dirac expressions, which eases concise specifications, and proofs can exploit local and parallel reasoning, which minimizes verification effort. We illustrate the applicability of CoqQ with many examples from the literature.},
  keywords = {quantum programs, program logics, proof assistants, mathematical libraries},
  note = {To appear at POPL '23.},
  webnote = {To appear at POPL '23.},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<a name="Zorzi2019"></a><pre>
@article{<a href="bbt.html#Zorzi2019">Zorzi2019</a>,
  title = {Quantum Calculi---From Theory to Language Design},
  author = {Zorzi, Margherita},
  year = {2019},
  month = dec,
  journal = {Applied Sciences},
  volume = {9},
  number = {24},
  eid = {5472},
  pages = {5472},
  doi = {10.3390/app9245472},
  abstract = {In the last 20 years, several approaches to quantum programming have been introduced. In this survey, we focus on the QRAM (Quantum Random Access Machine) architectural model. We explore the twofold perspective (theoretical and concrete) of the approach and we list the main problems one has to face in quantum language design. Moreover, we propose an overview of some interesting languages and open-source platforms for quantum programming currently available. We also provide the higher-order encoding in the functional languages qPCF and IQu of the well known Deutsch-Jozsa and Simon's algorithms.},
  keywords = {quantum language design, quantum computing, programming theory},
  bibsource = {Quantum Programming Languages \& Verification Bibliography, https://git.io/qpl-bib}
}
</pre>

<hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
<a href=./bbt.html>Go home</a>.</body>
</html>
