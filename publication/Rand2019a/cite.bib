@inproceedings{Rand2019a,
 title = {{Formal Verification vs. Quantum Uncertainty}},
 author = {Rand, Robert and Hietala, Kesha and Hicks, Michael},
 year = {2019},
 month = {July},
 booktitle = {3rd Summit on Advances in Programming Languages (SNAPL 2019)},
 editor = {Benjamin S. Lerner and Rastislav Bod{\'i}k and Shriram Krishnamurthi},
 publisher = {{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik}},
 address = {Dagstuhl, Germany},
 series = {Leibniz International Proceedings in Informatics (LIPIcs)},
 volume = {136},
 eid = {12},
 pages = {12:1--12:11},
 doi = {10.4230/LIPIcs.SNAPL.2019.12},
 abstract = {Quantum programming is hard: Quantum programs are necessarily probabilistic and impossible to examine without disrupting the execution of a program. In response to this challenge, we and a number of other researchers have written tools to verify quantum programs against their intended semantics. This is not enough. Verifying an idealized semantics against a real world quantum program doesn't allow you to confidently predict the program's output. In order to have verification that works, you need both an error semantics related to the hardware at hand (this is necessarily low level) and certified compilation to the that same hardware. Once we have these two things, we can talk about an approach to quantum programming where we start by writing and verifying programs at a high level, attempt to verify properties of the compiled code, and repeat as necessary.},
 keywords = {formal verification, quantum computing, programming languages, quantum error correction, certified compilation, nisq}
}

